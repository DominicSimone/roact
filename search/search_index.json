{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Roact is a declarative Lua UI library similar to Facebook's React . It exposes a very similar API and implements nearly identical semantics. This documentation is based on the structure of React's documentation, but is a work in progress. Many things from React also apply to Roact, but if you find anything missing or incorrect, open an issue on GitHub ! Info This documentation assumes some familiarity with Lua. If you're new to Lua, Programming in Lua by Roberto Ierusalimschy is a good introduction, and the first edition (for Lua 5.0) is available online for free.","title":"Home"},{"location":"api-reference/","text":"Methods \u00b6 Roact.createElement \u00b6 Roact.createElement(component, [props, [children]]) -> RoactElement Creates a new Roact element representing the given component . Elements are lightweight descriptions about what a Roblox Instance should look like, like a blueprint! The children argument is shorthand for adding a Roact.Children key to props . It should be specified as a dictionary of names to elements. component can be a string, a function, or a table created by Component:extend . Caution Once props or children are passed into the createElement , make sure not to modify them! Roact.mount \u00b6 Roact.mount(element, [parent, [key]]) -> ComponentInstanceHandle Info Roact.mount is also available via the deprecated alias Roact.reify . It will be removed in a future release. Creates a Roblox Instance given a Roact element, and optionally a parent to put it in, and a key to use as the instance's Name . The result is a ComponentInstanceHandle , which is an opaque handle that represents this specific instance of the root component. You can pass this to APIs like Roact.unmount and the future debug API. Roact.reconcile \u00b6 Roact.reconcile(instanceHandle, element) -> ComponentInstanceHandle Updates an existing instance handle with a new element, returning a new handle. This can be used to update a UI created with Roact.mount by passing in a new element with new props. reconcile can be used to change the props of a component instance created with mount and is useful for putting Roact content into non-Roact applications. Warning Roact.reconcile takes ownership of the instanceHandle passed into it and may unmount it and mount a new tree! Make sure to use the handle that reconcile returns in any operations after reconcile , including unmount . Roact.unmount \u00b6 Roact.unmount(instance) -> void Info Roact.unmount is also available via the deprecated alias Roact.teardown . It will be removed in a future release. Destroys the given ComponentInstanceHandle and all of its descendents. Does not operate on a Roblox Instance -- this must be given a handle that was returned by Roact.mount . Roact.oneChild \u00b6 Roact.oneChild(children) -> RoactElement | nil Given a dictionary of children, returns a single child element. If children contains more than one child, oneChild function will throw an error. This is intended to denote an error when using the component using oneChild . If children is nil or contains no children, oneChild will return nil . Roact.createRef \u00b6 Roact.createRef() -> Ref Creates a new reference object that can be used with Roact.Ref . Constants \u00b6 Roact.Children \u00b6 This is the key that Roact uses internally to store the children that are attached to a Roact element. If you're writing a new functional or stateful element that needs to be used like a primitive component, you can access Roact.Children in your props table. Roact.Ref \u00b6 Use Roact.Ref as a key into the props of a primitive element to receive a handle to the underlying Roblox Instance. Assign this key to a reference object created with createRef : local ExampleComponent = Roact . Component : extend ( \"ExampleComponent\" ) function ExampleComponent : init () -- Create a reference object. self . ref = Roact . createRef () end function ExampleComponent : render () return Roact . createElement ( \"Frame\" , { -- Use the reference object to point to this rendered instance. [ Roact . Ref ] = self . ref , }) end function ExampleComponent : didMount () -- Access the current value of a reference object using its current property. print ( \"Roblox Instance\" , self . ref . current ) end Alternatively, you can assign it to a function instead: Roact . createElement ( \"Frame\" , { -- The provided function will be called whenever the rendered instance changes. [ Roact . Ref ] = function ( rbx ) print ( \"Roblox Instance\" , rbx ) end , }) Warning When Roact.Ref is given a funciton, Roact does not guarantee when this function will be run relative to the reconciliation of other props. If you try to read a Roblox property that's being set via a Roact prop, you won't know if you're reading it before or after Roact reconciles that prop! Warning When Roact.Ref is given a funciton, it will be called with nil when the component instance is destroyed! See the refs guide for more details. Roact.Event \u00b6 Index into Roact.Event to receive a key that can be used to connect to events when creating primitive elements: Roact . createElement ( \"ImageButton\" , { [ Roact . Event . MouseButton1Click ] = function ( rbx , x , y ) print ( rbx , \"clicked at position\" , x , y ) end , }) Info Event callbacks receive the Roblox Instance as the first parameter, followed by any parameters yielded by the event. Warning When connecting to the Changed event, be careful not to call setState or other functions that will trigger renders. This will cause Roact to re-render during a render, and errors will be thrown! See the events guide for more details. Roact.Change \u00b6 Index into Roact.Change to receive a key that can be used to connect to GetPropertyChangedSignal events. It's similar to Roact.Event : Roact . createElement ( \"ScrollingFrame\" , { [ Roact . Change . CanvasPosition ] = function ( rbx , position ) print ( \"ScrollingFrame scrolled to\" , position ) end , }) Warning Property changed events are fired by Roact during the reconciliation phase. Be careful not to accidentally trigger a re-render in the middle of a re-render, or an error will be thrown! Roact.None \u00b6 Roact.None is a special value that can be used to clear elements from your component state when calling setState or returning from getDerivedStateFromProps . In Lua tables, removing a field from state is not possible by setting its value to nil because nil values mean the same thing as no value at all. If a field needs to be removed from state, it can be set to Roact.None when calling setState , which will ensure that the resulting state no longer contains it: function MyComponent : didMount () self : setState ({ fieldToRemove = Roact . None }) end Component Types \u00b6 Roact.Component \u00b6 The base component instance that can be extended to make stateful components. Call Roact.Component:extend(\"ComponentName\") to make a new stateful component with a given name. Roact.PureComponent \u00b6 An extension of Roact.Component that only re-renders if its props or state change. PureComponent implements the shouldUpdate lifecycle event with a shallow equality comparison. It's optimized for use with immutable data structures, which makes it a perfect fit for use with frameworks like Rodux. PureComponent is not always faster, but can often result in significant performance improvements when used correctly. Roact.Portal \u00b6 A component that represents a portal to a Roblox Instance. Portals are created using Roact.createElement . Any children of a portal are put inside the Roblox Instance specified by the required target prop. That Roblox Instance should not be one created by Roact. Portals are useful for creating dialogs managed by deeply-nested UI components, and enable Roact to represent and manage multiple disjoint trees at once. See the Portals guide for a small tutorial and more details about portals. Component API \u00b6 defaultProps \u00b6 static defaultProps: Dictionary<any, any> If defaultProps is defined on a stateful component, any props that aren't specified when a component is created will be taken from there. init \u00b6 init(initialProps) -> void init is called exactly once when a new instance of a component is created. It can be used to set up the initial state , as well as any non- render related values directly on the component. Use setState inside of init to set up your initial component state: function MyComponent : init () self : setState ({ position = 0 , velocity = 10 }) end In older versions of Roact, setState was disallowed in init , and you would instead assign to state directly. It's simpler to use setState , but assigning directly to state is still acceptable inside init : function MyComponent : init () self . state = { position = 0 , velocity = 10 } end render \u00b6 render() -> Element | nil render describes what a component should display at the current instant in time. Info Roact assumes that render act likes a pure function: the result of render must depend only on props and state , and it must not have side-effects. function MyComponent : render () -- This is okay: return Roact . createElement ( \"TextLabel\" , { Text = self . props . text , Position = self . state . position }) -- Ack! Depending on values outside props/state is not allowed! return Roact . createElement ( \"TextLabel\" , { Text = self . someText , Position = getMousePosition (), }) end render must be defined for all components. The default implementation of render throws an error; if your component does not render anything, define a render function that returns nil explicitly. This helps make sure that you don't forget to define render ! function MyComponent : render () return nil end setState \u00b6 setState(stateUpdater | stateChange) -> void setState requests an update to the component's state. Roact may schedule this update for a later time or resolve it immediately. If a function is passed to setState , that function will be called with the current state and props as arguments: function MyComponent : didMount () self : setState ( function ( prevState , props ) return { counter = prevState . counter + 1 } end ) end If this function returns nil , Roact will not schedule a re-render and no state will be updated. If a table is passed to setState , the values in that table will be merged onto the existing state: function MyComponent : didMount () self : setState ({ foo = \"bar\" }) end Setting a field in the state to Roact.None will clear it from the state. This is the only way to remove a field from a component's state! Warning setState can be called from anywhere except : Lifecycle hooks: willUnmount , willUpdate Pure functions: render , shouldUpdate Calling setState inside of init has special behavior. The result of setState will be used to determine initial state, and no additional updates will be scheduled. Roact may support calling setState in currently-disallowed places in the future. Warning setState does not always resolve synchronously! Roact may batch and reschedule state updates in order to reduce the number of total renders. When depending on the previous value of state, like when incrementing a counter, use the functional form to guarantee that all state updates occur! This behavior will be similar to the future behavior of React 17. See: RFClarification: why is setState asynchronous? Does React keep the order for state updates? shouldUpdate \u00b6 shouldUpdate(nextProps, nextState) -> bool shouldUpdate provides a way to override Roact's rerendering heuristics. By default, components are re-rendered any time a parent component updates, or when state is updated via setState . PureComponent implements shouldUpdate to only trigger a re-render any time the props are different based on shallow equality. In a future Roact update, all components may implement this check by default. getElementTraceback \u00b6 getElementTraceback() -> string | nil getElementTraceback gets the stack trace that the component was created in. This allows you to report error messages accurately. Lifecycle Methods \u00b6 In addition to the base Component API, Roact exposes additional lifecycle methods that stateful components can hook into to be notified of various steps in the rendering process. didMount \u00b6 didMount() -> void didMount is fired after the component finishes its initial render. At this point, all associated Roblox Instances have been created, and all components have finished mounting. didMount is a good place to start initial network communications, attach events to services, or modify the Roblox Instance hierarchy. willUnmount \u00b6 willUnmount() -> void willUnmount is fired right before Roact begins unmounting a component instance's children. willUnmount acts like a component's destructor, and is a good place to disconnect any manually-connected events. willUpdate \u00b6 willUpdate(nextProps, nextState) -> void willUpdate is fired after an update is started but before a component's state and props are updated. didUpdate \u00b6 didUpdate(previousProps, previousState) -> void didUpdate is fired after at the end of an update. At this point, the reconciler has updated the properties of any Roblox Instances and the component instance's props and state are up to date. didUpdate is a good place to send network requests or dispatch Rodux actions, but make sure to compare self.props and self.state with previousProps and previousState to avoid triggering too many updates. getDerivedStateFromProps \u00b6 static getDerivedStateFromProps(nextProps, lastState) -> nextStateSlice Used to recalculate any state that depends on being synchronized with props . Generally, you should use didUpdate to respond to props changing. If you find yourself copying props values to state as-is, consider using props or memoization instead. getDerivedStateFromProps should return a table that contains the part of the state that should be updated. function MyComponent . getDerivedStateFromProps ( nextProps , lastState ) return { someValue = nextProps . someValue } end As with setState , you can set use the constant Roact.None to remove a field from the state. Note getDerivedStateFromProps is a static lifecycle method. It does not have access to self , and must be a pure function.","title":"API Reference"},{"location":"api-reference/#methods","text":"","title":"Methods"},{"location":"api-reference/#roactcreateelement","text":"Roact.createElement(component, [props, [children]]) -> RoactElement Creates a new Roact element representing the given component . Elements are lightweight descriptions about what a Roblox Instance should look like, like a blueprint! The children argument is shorthand for adding a Roact.Children key to props . It should be specified as a dictionary of names to elements. component can be a string, a function, or a table created by Component:extend . Caution Once props or children are passed into the createElement , make sure not to modify them!","title":"Roact.createElement"},{"location":"api-reference/#roactmount","text":"Roact.mount(element, [parent, [key]]) -> ComponentInstanceHandle Info Roact.mount is also available via the deprecated alias Roact.reify . It will be removed in a future release. Creates a Roblox Instance given a Roact element, and optionally a parent to put it in, and a key to use as the instance's Name . The result is a ComponentInstanceHandle , which is an opaque handle that represents this specific instance of the root component. You can pass this to APIs like Roact.unmount and the future debug API.","title":"Roact.mount"},{"location":"api-reference/#roactreconcile","text":"Roact.reconcile(instanceHandle, element) -> ComponentInstanceHandle Updates an existing instance handle with a new element, returning a new handle. This can be used to update a UI created with Roact.mount by passing in a new element with new props. reconcile can be used to change the props of a component instance created with mount and is useful for putting Roact content into non-Roact applications. Warning Roact.reconcile takes ownership of the instanceHandle passed into it and may unmount it and mount a new tree! Make sure to use the handle that reconcile returns in any operations after reconcile , including unmount .","title":"Roact.reconcile"},{"location":"api-reference/#roactunmount","text":"Roact.unmount(instance) -> void Info Roact.unmount is also available via the deprecated alias Roact.teardown . It will be removed in a future release. Destroys the given ComponentInstanceHandle and all of its descendents. Does not operate on a Roblox Instance -- this must be given a handle that was returned by Roact.mount .","title":"Roact.unmount"},{"location":"api-reference/#roactonechild","text":"Roact.oneChild(children) -> RoactElement | nil Given a dictionary of children, returns a single child element. If children contains more than one child, oneChild function will throw an error. This is intended to denote an error when using the component using oneChild . If children is nil or contains no children, oneChild will return nil .","title":"Roact.oneChild"},{"location":"api-reference/#roactcreateref","text":"Roact.createRef() -> Ref Creates a new reference object that can be used with Roact.Ref .","title":"Roact.createRef"},{"location":"api-reference/#constants","text":"","title":"Constants"},{"location":"api-reference/#roactchildren","text":"This is the key that Roact uses internally to store the children that are attached to a Roact element. If you're writing a new functional or stateful element that needs to be used like a primitive component, you can access Roact.Children in your props table.","title":"Roact.Children"},{"location":"api-reference/#roactref","text":"Use Roact.Ref as a key into the props of a primitive element to receive a handle to the underlying Roblox Instance. Assign this key to a reference object created with createRef : local ExampleComponent = Roact . Component : extend ( \"ExampleComponent\" ) function ExampleComponent : init () -- Create a reference object. self . ref = Roact . createRef () end function ExampleComponent : render () return Roact . createElement ( \"Frame\" , { -- Use the reference object to point to this rendered instance. [ Roact . Ref ] = self . ref , }) end function ExampleComponent : didMount () -- Access the current value of a reference object using its current property. print ( \"Roblox Instance\" , self . ref . current ) end Alternatively, you can assign it to a function instead: Roact . createElement ( \"Frame\" , { -- The provided function will be called whenever the rendered instance changes. [ Roact . Ref ] = function ( rbx ) print ( \"Roblox Instance\" , rbx ) end , }) Warning When Roact.Ref is given a funciton, Roact does not guarantee when this function will be run relative to the reconciliation of other props. If you try to read a Roblox property that's being set via a Roact prop, you won't know if you're reading it before or after Roact reconciles that prop! Warning When Roact.Ref is given a funciton, it will be called with nil when the component instance is destroyed! See the refs guide for more details.","title":"Roact.Ref"},{"location":"api-reference/#roactevent","text":"Index into Roact.Event to receive a key that can be used to connect to events when creating primitive elements: Roact . createElement ( \"ImageButton\" , { [ Roact . Event . MouseButton1Click ] = function ( rbx , x , y ) print ( rbx , \"clicked at position\" , x , y ) end , }) Info Event callbacks receive the Roblox Instance as the first parameter, followed by any parameters yielded by the event. Warning When connecting to the Changed event, be careful not to call setState or other functions that will trigger renders. This will cause Roact to re-render during a render, and errors will be thrown! See the events guide for more details.","title":"Roact.Event"},{"location":"api-reference/#roactchange","text":"Index into Roact.Change to receive a key that can be used to connect to GetPropertyChangedSignal events. It's similar to Roact.Event : Roact . createElement ( \"ScrollingFrame\" , { [ Roact . Change . CanvasPosition ] = function ( rbx , position ) print ( \"ScrollingFrame scrolled to\" , position ) end , }) Warning Property changed events are fired by Roact during the reconciliation phase. Be careful not to accidentally trigger a re-render in the middle of a re-render, or an error will be thrown!","title":"Roact.Change"},{"location":"api-reference/#roactnone","text":"Roact.None is a special value that can be used to clear elements from your component state when calling setState or returning from getDerivedStateFromProps . In Lua tables, removing a field from state is not possible by setting its value to nil because nil values mean the same thing as no value at all. If a field needs to be removed from state, it can be set to Roact.None when calling setState , which will ensure that the resulting state no longer contains it: function MyComponent : didMount () self : setState ({ fieldToRemove = Roact . None }) end","title":"Roact.None"},{"location":"api-reference/#component-types","text":"","title":"Component Types"},{"location":"api-reference/#roactcomponent","text":"The base component instance that can be extended to make stateful components. Call Roact.Component:extend(\"ComponentName\") to make a new stateful component with a given name.","title":"Roact.Component"},{"location":"api-reference/#roactpurecomponent","text":"An extension of Roact.Component that only re-renders if its props or state change. PureComponent implements the shouldUpdate lifecycle event with a shallow equality comparison. It's optimized for use with immutable data structures, which makes it a perfect fit for use with frameworks like Rodux. PureComponent is not always faster, but can often result in significant performance improvements when used correctly.","title":"Roact.PureComponent"},{"location":"api-reference/#roactportal","text":"A component that represents a portal to a Roblox Instance. Portals are created using Roact.createElement . Any children of a portal are put inside the Roblox Instance specified by the required target prop. That Roblox Instance should not be one created by Roact. Portals are useful for creating dialogs managed by deeply-nested UI components, and enable Roact to represent and manage multiple disjoint trees at once. See the Portals guide for a small tutorial and more details about portals.","title":"Roact.Portal"},{"location":"api-reference/#component-api","text":"","title":"Component API"},{"location":"api-reference/#defaultprops","text":"static defaultProps: Dictionary<any, any> If defaultProps is defined on a stateful component, any props that aren't specified when a component is created will be taken from there.","title":"defaultProps"},{"location":"api-reference/#init","text":"init(initialProps) -> void init is called exactly once when a new instance of a component is created. It can be used to set up the initial state , as well as any non- render related values directly on the component. Use setState inside of init to set up your initial component state: function MyComponent : init () self : setState ({ position = 0 , velocity = 10 }) end In older versions of Roact, setState was disallowed in init , and you would instead assign to state directly. It's simpler to use setState , but assigning directly to state is still acceptable inside init : function MyComponent : init () self . state = { position = 0 , velocity = 10 } end","title":"init"},{"location":"api-reference/#render","text":"render() -> Element | nil render describes what a component should display at the current instant in time. Info Roact assumes that render act likes a pure function: the result of render must depend only on props and state , and it must not have side-effects. function MyComponent : render () -- This is okay: return Roact . createElement ( \"TextLabel\" , { Text = self . props . text , Position = self . state . position }) -- Ack! Depending on values outside props/state is not allowed! return Roact . createElement ( \"TextLabel\" , { Text = self . someText , Position = getMousePosition (), }) end render must be defined for all components. The default implementation of render throws an error; if your component does not render anything, define a render function that returns nil explicitly. This helps make sure that you don't forget to define render ! function MyComponent : render () return nil end","title":"render"},{"location":"api-reference/#setstate","text":"setState(stateUpdater | stateChange) -> void setState requests an update to the component's state. Roact may schedule this update for a later time or resolve it immediately. If a function is passed to setState , that function will be called with the current state and props as arguments: function MyComponent : didMount () self : setState ( function ( prevState , props ) return { counter = prevState . counter + 1 } end ) end If this function returns nil , Roact will not schedule a re-render and no state will be updated. If a table is passed to setState , the values in that table will be merged onto the existing state: function MyComponent : didMount () self : setState ({ foo = \"bar\" }) end Setting a field in the state to Roact.None will clear it from the state. This is the only way to remove a field from a component's state! Warning setState can be called from anywhere except : Lifecycle hooks: willUnmount , willUpdate Pure functions: render , shouldUpdate Calling setState inside of init has special behavior. The result of setState will be used to determine initial state, and no additional updates will be scheduled. Roact may support calling setState in currently-disallowed places in the future. Warning setState does not always resolve synchronously! Roact may batch and reschedule state updates in order to reduce the number of total renders. When depending on the previous value of state, like when incrementing a counter, use the functional form to guarantee that all state updates occur! This behavior will be similar to the future behavior of React 17. See: RFClarification: why is setState asynchronous? Does React keep the order for state updates?","title":"setState"},{"location":"api-reference/#shouldupdate","text":"shouldUpdate(nextProps, nextState) -> bool shouldUpdate provides a way to override Roact's rerendering heuristics. By default, components are re-rendered any time a parent component updates, or when state is updated via setState . PureComponent implements shouldUpdate to only trigger a re-render any time the props are different based on shallow equality. In a future Roact update, all components may implement this check by default.","title":"shouldUpdate"},{"location":"api-reference/#getelementtraceback","text":"getElementTraceback() -> string | nil getElementTraceback gets the stack trace that the component was created in. This allows you to report error messages accurately.","title":"getElementTraceback"},{"location":"api-reference/#lifecycle-methods","text":"In addition to the base Component API, Roact exposes additional lifecycle methods that stateful components can hook into to be notified of various steps in the rendering process.","title":"Lifecycle Methods"},{"location":"api-reference/#didmount","text":"didMount() -> void didMount is fired after the component finishes its initial render. At this point, all associated Roblox Instances have been created, and all components have finished mounting. didMount is a good place to start initial network communications, attach events to services, or modify the Roblox Instance hierarchy.","title":"didMount"},{"location":"api-reference/#willunmount","text":"willUnmount() -> void willUnmount is fired right before Roact begins unmounting a component instance's children. willUnmount acts like a component's destructor, and is a good place to disconnect any manually-connected events.","title":"willUnmount"},{"location":"api-reference/#willupdate","text":"willUpdate(nextProps, nextState) -> void willUpdate is fired after an update is started but before a component's state and props are updated.","title":"willUpdate"},{"location":"api-reference/#didupdate","text":"didUpdate(previousProps, previousState) -> void didUpdate is fired after at the end of an update. At this point, the reconciler has updated the properties of any Roblox Instances and the component instance's props and state are up to date. didUpdate is a good place to send network requests or dispatch Rodux actions, but make sure to compare self.props and self.state with previousProps and previousState to avoid triggering too many updates.","title":"didUpdate"},{"location":"api-reference/#getderivedstatefromprops","text":"static getDerivedStateFromProps(nextProps, lastState) -> nextStateSlice Used to recalculate any state that depends on being synchronized with props . Generally, you should use didUpdate to respond to props changing. If you find yourself copying props values to state as-is, consider using props or memoization instead. getDerivedStateFromProps should return a table that contains the part of the state that should be updated. function MyComponent . getDerivedStateFromProps ( nextProps , lastState ) return { someValue = nextProps . someValue } end As with setState , you can set use the constant Roact.None to remove a field from the state. Note getDerivedStateFromProps is a static lifecycle method. It does not have access to self , and must be a pure function.","title":"getDerivedStateFromProps"},{"location":"advanced/context/","text":"Warning Context is an unstable feature that's being significantly revised. See issue #4 for current progress. Info This section is incomplete. It's possible that the context API will change before the existing API is ever documented.","title":"Context"},{"location":"advanced/portals/","text":"Portals are a special kind of component provided by Roact that enable components to render objects into a separate, non-Roact Instance. Info Eventually, there will be a diagram of Roact portals here. For now, just imagine Valve's hit game, Portal . To create a portal, use the Roact.Portal component with createElement : local function PartInWorkspace ( props ) return Roact . createElement ( Roact . Portal , { target = Workspace }, { SomePart = Roact . createElement ( \"Part\" , { Anchored = true }) }) end When we create PartInWorkspace , even if it's deep into our Roact tree, a Part Instance named SomePart will be created in Workspace . Warning Portals should only be created to objects that aren't managed by Roact! One particularly good use for portals is full-screen modal dialogs. When we render a modal dialog, we want it to take over the entire screen, but we want components deep in the tree to be able to create them! local PlayerGui = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui -- Our Modal component is a standard component, but with a portal at the top! local function Modal ( props ) return Roact . createElement ( Roact . Portal , { target = PlayerGui }, { Modal = Roact . createElement ( \"ScreenGui\" , {}, { Label = Roact . createElement ( \"TextButton\" , { Size = UDim2 . new ( 1 , 0 , 1 , 0 ), Text = \"Click me to close!\" , [ Roact . Event . Activated ] = function () props . onClose () end }) }) }) end -- A ModalButton contains a little bit of state to decide whether the dialog -- should be open or not. local ModalButton = Roact . Component : extend ( \"ModalButton\" ) function ModalButton : init () self . state = { dialogOpen = false } end function ModalButton : render () local dialog = nil -- If the dialog isn't open, just avoid rendering it. if self . state . dialogOpen then dialog = Roact . createElement ( Modal , { onClose = function () self : setState ({ dialogOpen = false }) end }) end return Roact . createElement ( \"TextButton\" , { Size = UDim2 . new ( 0 , 400 , 0 , 300 ), Text = \"Click me to open modal dialog!\" , [ Roact . Event . Activated ] = function () self : setState ({ dialogOpen = true }) end }, { -- If `dialog` ends up nil, this line does nothing! Dialog = dialog }) end","title":"Portals"},{"location":"advanced/refs/","text":"Refs grant access to the Roblox Instance objects that are created by Roact. They're an escape hatch for when something is difficult or impossible to correctly express with the Roact API. Refs are intended to be used in cases where Roact cannot solve a problem directly, or its solution might not be performant enough, like: Resizing a box to fit its contents dynamically Gamepad selection Animations Refs can only be attached to primitive components. This is different than React, where refs can be used to call members of composite components. Refs in Action \u00b6 To use a ref, call Roact.createRef() and put the result somewhere persistent. Generally, that means that refs are only used inside stateful components. local Foo = Roact . Component : extend ( \"Foo\" ) function Foo : init () self . textBoxRef = Roact . createRef () end Next, use the ref inside of render by creating a primitive component. Refs use the special key Roact.Ref . function Foo : render () return Roact . createElement ( \"TextBox\" , { [ Roact . Ref ] = self . textBoxRef , }) end Finally, we can use the value of the ref at any point after our component is mounted. function Foo : didMount () -- The actual Instance is stored in the 'current' property of a ref object. local textBox = self . textBoxRef . current print ( \"TextBox has this text:\" , textBox . Text ) end Function Refs \u00b6 The original ref API was based on functions instead of objects. Its use is not recommended for most cases anymore, but it can still be useful in some cases. This style of ref involves passing a function as the Roact.Ref prop as opposed to a dedicated ref object: local function Bar ( props ) return Roact . createElement ( \"TextBox\" , { [ Roact . Ref ] = function ( instance ) -- Be careful to guard against nil refs; this is a gotcha of -- function refs. if instance ~= nil then print ( \"TextBox has this text:\" , instance . Text ) else print ( \"TextBox ref removed.\" ) end end , }) end Warning When a function ref is called, it's not guaranteed that its sibling or parent components have finished mounting. Causing side effects here can cause difficult-to-trace bugs. Warning When a component with a function ref unmounts, or when the ref value changes, the component's ref is passed nil .","title":"Refs"},{"location":"advanced/refs/#refs-in-action","text":"To use a ref, call Roact.createRef() and put the result somewhere persistent. Generally, that means that refs are only used inside stateful components. local Foo = Roact . Component : extend ( \"Foo\" ) function Foo : init () self . textBoxRef = Roact . createRef () end Next, use the ref inside of render by creating a primitive component. Refs use the special key Roact.Ref . function Foo : render () return Roact . createElement ( \"TextBox\" , { [ Roact . Ref ] = self . textBoxRef , }) end Finally, we can use the value of the ref at any point after our component is mounted. function Foo : didMount () -- The actual Instance is stored in the 'current' property of a ref object. local textBox = self . textBoxRef . current print ( \"TextBox has this text:\" , textBox . Text ) end","title":"Refs in Action"},{"location":"advanced/refs/#function-refs","text":"The original ref API was based on functions instead of objects. Its use is not recommended for most cases anymore, but it can still be useful in some cases. This style of ref involves passing a function as the Roact.Ref prop as opposed to a dedicated ref object: local function Bar ( props ) return Roact . createElement ( \"TextBox\" , { [ Roact . Ref ] = function ( instance ) -- Be careful to guard against nil refs; this is a gotcha of -- function refs. if instance ~= nil then print ( \"TextBox has this text:\" , instance . Text ) else print ( \"TextBox ref removed.\" ) end end , }) end Warning When a function ref is called, it's not guaranteed that its sibling or parent components have finished mounting. Causing side effects here can cause difficult-to-trace bugs. Warning When a component with a function ref unmounts, or when the ref value changes, the component's ref is passed nil .","title":"Function Refs"},{"location":"guide/components/","text":"Components are encapsulated, reusable pieces of UI that you can combine to build a complete UI. Components accept inputs, known as props , and return elements to describe the UI that should represent those inputs. Functional and Stateful Components \u00b6 Components come in two flavors in Roact, functional and stateful . Functional components are the simplest: they're just functions that accept props as their only argument, and return some elements. local function Greeting ( props ) return Roact . createElement ( \"TextLabel\" , { Text = \"Hello, \" .. props . name }) end Roact also has stateful components, which have additional features, like lifecycle methods and state, that we'll talk about in a later section. You can create a stateful component by calling Roact.Component:extend and passing in the component's name. local Greeting = Roact . Component : extend ( \"Greeting\" ) function Greeting : render () return Roact . createElement ( \"TextLabel\" , { Text = \"Hello, \" .. self . props . name }) end Using Components \u00b6 In our previous examples, we passed strings to Roact.createElement to create elements that represented Roblox Instances. We can also pass our custom components to create elements that represent them: local hello = Roact . createElement ( Greeting , { name = \"Rick James\" }) The name value is passed to our component as props, which we can reference as the props argument in our functional component or self.props in our stateful component. Components in Components \u00b6 Components are designed to make it easy to re-use pieces of UI, so naturally, we can use components inside other components! local function Greeting ( props ) return Roact . createElement ( \"TextLabel\" , { Text = \"Hello, \" .. props . name }) end local function GreetEveryone () return Roact . createElement ( \"ScreenGui\" , { Layout = Roact . createElement ( \"UIListLayout\" ), HelloJoe = Roact . createElement ( Greeting , { name = \"Joe\" }), HelloMary = Roact . createElement ( Greeting , { name = \"Mary\" }) }) end Applications built using Roact usually have one component at the top of the tree, and include all other pieces as children. Incrementing Counter, Part Two \u00b6 We can revisit the incrementing counter example from the previous section, now using a functional component. Changed sections are highlighted. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Roact = require ( ReplicatedStorage . Roact ) -- Create a functional component that represents our UI local function Clock ( props ) local currentTime = props . currentTime return Roact . createElement ( \"ScreenGui\" , {}, { TimeLabel = Roact . createElement ( \"TextLabel\" , { Size = UDim2 . new ( 1 , 0 , 1 , 0 ), Text = \"Time Elapsed: \" .. currentTime }) }) end local PlayerGui = Players . LocalPlayer . PlayerGui -- Create our initial UI. local currentTime = 0 local clockElement = Roact . createElement ( Clock , { currentTime = currentTime }) local handle = Roact . mount ( clockElement , PlayerGui , \"Clock UI\" ) -- Every second, update the UI to show our new time. while true do wait ( 1 ) currentTime = currentTime + 1 handle = Roact . reconcile ( handle , Roact . createElement ( Clock , { currentTime = currentTime })) end","title":"Components"},{"location":"guide/components/#functional-and-stateful-components","text":"Components come in two flavors in Roact, functional and stateful . Functional components are the simplest: they're just functions that accept props as their only argument, and return some elements. local function Greeting ( props ) return Roact . createElement ( \"TextLabel\" , { Text = \"Hello, \" .. props . name }) end Roact also has stateful components, which have additional features, like lifecycle methods and state, that we'll talk about in a later section. You can create a stateful component by calling Roact.Component:extend and passing in the component's name. local Greeting = Roact . Component : extend ( \"Greeting\" ) function Greeting : render () return Roact . createElement ( \"TextLabel\" , { Text = \"Hello, \" .. self . props . name }) end","title":"Functional and Stateful Components"},{"location":"guide/components/#using-components","text":"In our previous examples, we passed strings to Roact.createElement to create elements that represented Roblox Instances. We can also pass our custom components to create elements that represent them: local hello = Roact . createElement ( Greeting , { name = \"Rick James\" }) The name value is passed to our component as props, which we can reference as the props argument in our functional component or self.props in our stateful component.","title":"Using Components"},{"location":"guide/components/#components-in-components","text":"Components are designed to make it easy to re-use pieces of UI, so naturally, we can use components inside other components! local function Greeting ( props ) return Roact . createElement ( \"TextLabel\" , { Text = \"Hello, \" .. props . name }) end local function GreetEveryone () return Roact . createElement ( \"ScreenGui\" , { Layout = Roact . createElement ( \"UIListLayout\" ), HelloJoe = Roact . createElement ( Greeting , { name = \"Joe\" }), HelloMary = Roact . createElement ( Greeting , { name = \"Mary\" }) }) end Applications built using Roact usually have one component at the top of the tree, and include all other pieces as children.","title":"Components in Components"},{"location":"guide/components/#incrementing-counter-part-two","text":"We can revisit the incrementing counter example from the previous section, now using a functional component. Changed sections are highlighted. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Roact = require ( ReplicatedStorage . Roact ) -- Create a functional component that represents our UI local function Clock ( props ) local currentTime = props . currentTime return Roact . createElement ( \"ScreenGui\" , {}, { TimeLabel = Roact . createElement ( \"TextLabel\" , { Size = UDim2 . new ( 1 , 0 , 1 , 0 ), Text = \"Time Elapsed: \" .. currentTime }) }) end local PlayerGui = Players . LocalPlayer . PlayerGui -- Create our initial UI. local currentTime = 0 local clockElement = Roact . createElement ( Clock , { currentTime = currentTime }) local handle = Roact . mount ( clockElement , PlayerGui , \"Clock UI\" ) -- Every second, update the UI to show our new time. while true do wait ( 1 ) currentTime = currentTime + 1 handle = Roact . reconcile ( handle , Roact . createElement ( Clock , { currentTime = currentTime })) end","title":"Incrementing Counter, Part Two"},{"location":"guide/elements/","text":"Like React, everything in Roact is built out of elements. Elements are the smallest building blocks for creating UI. Elements describe what you want your UI to look like at a single point in time. They're immutable : you can't change elements once they're created, but you can create new ones. Because creating elements is fast, this is no big deal. You can create an element using Roact.createElement -- just pass a Roblox class name as the first argument, and any properties as the second argument! local myElement = Roact . createElement ( \"Frame\" , { Size = UDim2 . new ( 0 , 50 , 0 , 50 ) }) You can also represent children by passing them to the optional third argument of createElement : local myElement = Roact . createElement ( \"Frame\" , { Size = UDim2 . new ( 0 , 50 , 0 , 50 ) }, { SomeChild = Roact . createElement ( \"TextLabel\" , { Text = \"Hello, Roact!\" }) }) Creating an element by itself doesn't do anything, however. In order to turn our description of an object into a real Roblox Instance, we can call Roact.mount : -- Create a new Frame object in 'Workspace' local myHandle = Roact . mount ( myElement , game . Workspace ) Mounting is the process of creating a Roact component instance as well as any associated Roblox Instances. Roact.mount returns a handle that we can later use to update or destroy that object with Roact.reconcile and Roact.unmount . Changing What's Rendered \u00b6 In order to change the UI that we've created, we need to create a new set of elements and reconcile the existing tree to match it. Reconciliation is the term that Roact uses to describe the process of updating an existing UI to match what the program wants it to look like at any given time. Using myHandle from above, we can update the size and text of our label: -- Make some new elements that describe what our new UI will look like. local myNewElement = Roact . createElement ( \"Frame\" , { Size = UDim2 . new ( 0 , 100 , 0 , 50 ) }, { SomeChild = Roact . createElement ( \"TextLabel\" , { Text = \"Hello, again, Roact!\" }) }) -- Update our hierarchy to match those elements. myHandle = Roact . reconcile ( myHandle , myNewElement ) Info Most projects using UI don't use Roact.reconcile and instead change UI using state and lifecycle events, which will be introduced in the next section. Roact.reconcile is mostly useful to embed Roact components into existing, non-Roact projects, and for introducing Roact! Unlike many other UI systems, Roact doesn't let you directly set values on UI objects. Instead, describe what your UI should look like in the form of elements and Roact will handle changing the underlying Roblox Instances. Unmounting the Tree \u00b6 Roact provides a method called Roact.unmount that we can use when we're finished with our tree. Roact . unmount ( myHandle ) Unmounting destructs the given Roact component instance and destroys any associated Roblox Instances with it. Warning Trying to use a handle after it's been passed to Roact.unmount will result in errors! Incrementing Counter \u00b6 Using what's been covered so far, we can make a simple program that tells you how long it has been running. This is a complete example that should work when put into a LocalScript in StarterPlayerScripts . It assumes Roact has been installed into ReplicatedStorage . local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Roact = require ( ReplicatedStorage . Roact ) -- Create a function that creates the elements for our UI. -- Later, we'll use components, which are the best way to organize UI in Roact. local function clock ( currentTime ) return Roact . createElement ( \"ScreenGui\" , {}, { TimeLabel = Roact . createElement ( \"TextLabel\" , { Size = UDim2 . new ( 1 , 0 , 1 , 0 ), Text = \"Time Elapsed: \" .. currentTime }) }) end local PlayerGui = Players . LocalPlayer . PlayerGui -- Create our initial UI. local currentTime = 0 local handle = Roact . mount ( clock ( currentTime ), PlayerGui , \"Clock UI\" ) -- Every second, update the UI to show our new time. while true do wait ( 1 ) currentTime = currentTime + 1 handle = Roact . reconcile ( handle , clock ( currentTime )) end In the next section, we'll talk about components, which let us create reusable chunks of UI, and introduce the primary technique to change UI in Roact.","title":"Elements"},{"location":"guide/elements/#changing-whats-rendered","text":"In order to change the UI that we've created, we need to create a new set of elements and reconcile the existing tree to match it. Reconciliation is the term that Roact uses to describe the process of updating an existing UI to match what the program wants it to look like at any given time. Using myHandle from above, we can update the size and text of our label: -- Make some new elements that describe what our new UI will look like. local myNewElement = Roact . createElement ( \"Frame\" , { Size = UDim2 . new ( 0 , 100 , 0 , 50 ) }, { SomeChild = Roact . createElement ( \"TextLabel\" , { Text = \"Hello, again, Roact!\" }) }) -- Update our hierarchy to match those elements. myHandle = Roact . reconcile ( myHandle , myNewElement ) Info Most projects using UI don't use Roact.reconcile and instead change UI using state and lifecycle events, which will be introduced in the next section. Roact.reconcile is mostly useful to embed Roact components into existing, non-Roact projects, and for introducing Roact! Unlike many other UI systems, Roact doesn't let you directly set values on UI objects. Instead, describe what your UI should look like in the form of elements and Roact will handle changing the underlying Roblox Instances.","title":"Changing What's Rendered"},{"location":"guide/elements/#unmounting-the-tree","text":"Roact provides a method called Roact.unmount that we can use when we're finished with our tree. Roact . unmount ( myHandle ) Unmounting destructs the given Roact component instance and destroys any associated Roblox Instances with it. Warning Trying to use a handle after it's been passed to Roact.unmount will result in errors!","title":"Unmounting the Tree"},{"location":"guide/elements/#incrementing-counter","text":"Using what's been covered so far, we can make a simple program that tells you how long it has been running. This is a complete example that should work when put into a LocalScript in StarterPlayerScripts . It assumes Roact has been installed into ReplicatedStorage . local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Roact = require ( ReplicatedStorage . Roact ) -- Create a function that creates the elements for our UI. -- Later, we'll use components, which are the best way to organize UI in Roact. local function clock ( currentTime ) return Roact . createElement ( \"ScreenGui\" , {}, { TimeLabel = Roact . createElement ( \"TextLabel\" , { Size = UDim2 . new ( 1 , 0 , 1 , 0 ), Text = \"Time Elapsed: \" .. currentTime }) }) end local PlayerGui = Players . LocalPlayer . PlayerGui -- Create our initial UI. local currentTime = 0 local handle = Roact . mount ( clock ( currentTime ), PlayerGui , \"Clock UI\" ) -- Every second, update the UI to show our new time. while true do wait ( 1 ) currentTime = currentTime + 1 handle = Roact . reconcile ( handle , clock ( currentTime )) end In the next section, we'll talk about components, which let us create reusable chunks of UI, and introduce the primary technique to change UI in Roact.","title":"Incrementing Counter"},{"location":"guide/events/","text":"Roact manages Instance event connections automatically as part of rendering. To connect to an event, pass a prop with Roact.Event.EVENT_NAME as the key and a function as the value. Roact will pass the instance that the event is connected to as the first argument to the event callback, followed by any arguments that Roblox passed in. local button = Roact . createElement ( \"TextButton\" , { Text = \"Click me!\" , Size = UDim2 . new ( 0 , 400 , 0 , 300 ), [ Roact . Event . MouseButton1Click ] = function ( rbx ) print ( \"The button was clicked!\" ) end }) Info Events will automatically be disconnected when a component instance is unmounted! To listen to GetPropertyChangedSignal , Roact provides a similar API, using props like Roact.Change.PROPERTY_NAME : local frame = Roact . createElement ( \"Frame\" , { [ Roact . Change . AbsoluteSize ] = function ( rbx ) print ( \"Absolute size changed to\" , rbx . AbsoluteSize ) end }) Warning Roact can trigger events while updating the tree! If Roact triggers an event handler that calls setState synchronously, an error will be thrown. In the future, Roact may delay evaluation of event handlers to prevent them from happening while Roact is modifying the tree.","title":"Events"},{"location":"guide/hello-roact/","text":"Info These examples asssumes that you've successfully installed Roact into ReplicatedStorage ! Add a new LocalScript object to StarterPlayer.StarterPlayerScripts either in Roblox Studio, or via Rojo: local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Roact = require ( ReplicatedStorage . Roact ) local app = Roact . createElement ( \"ScreenGui\" , {}, { HelloWorld = Roact . createElement ( \"TextLabel\" , { Size = UDim2 . new ( 0 , 400 , 0 , 300 ), Text = \"Hello, Roact!\" }) }) Roact . mount ( app , Players . LocalPlayer . PlayerGui ) When you run your game, you should see a large gray label with the phrase 'Hello, Roact!' appear on screen!","title":"Hello, Roact!"},{"location":"guide/installation/","text":"There are two supported ways to get started with Roact. For our examples, we'll install Roact to ReplicatedStorage . In practice, it's okay to install Roact anywhere you want! Method 1: Model File (Roblox Studio) \u00b6 Download the rbxmx model file attached to the latest release from the GitHub releases page . Insert the model into Studio into a place like ReplicatedStorage Method 2: Filesystem \u00b6 Copy the lib directory into your codebase Rename the folder to Roact Use a plugin like Rojo to sync the files into a place","title":"Installation"},{"location":"guide/installation/#method-1-model-file-roblox-studio","text":"Download the rbxmx model file attached to the latest release from the GitHub releases page . Insert the model into Studio into a place like ReplicatedStorage","title":"Method 1: Model File (Roblox Studio)"},{"location":"guide/installation/#method-2-filesystem","text":"Copy the lib directory into your codebase Rename the folder to Roact Use a plugin like Rojo to sync the files into a place","title":"Method 2: Filesystem"},{"location":"guide/pure-component/","text":"TODO","title":"Pure component"},{"location":"guide/state-and-lifecycle/","text":"In the previous section, we talked about using components to create reusable chunks of state, and introduced functional and stateful components. Stateful components do everything that functional components do, but have the addition of mutable state and lifecycle methods . State \u00b6 State is the term we use to talk about values that are owned by a component itself. Unlike props , which are passed to a component from above, state is created within a component and can only be updated by that component. We can set up the initial state of a stateful component inside of a method named init : function MyComponent : init () self : setState ({ currentTime = 0 }) end To update state, we use a special method named setState . setState will merge any values we give it into our state. It will overwrite any existing values, and leave any values we don't specify alone. There's another form of setState we can use. When the new state we want our component to have depends on our current state, like incrementing a value, we use this form: -- This is another special method, didMount, that we'll talk about in a moment. function MyComponent : didMount () self : setState ( function ( state ) return { currentTime = currentTime + state . currentTime } end ) end In this case, we're passing a function to setState . This function is called and passed the current state, and returns a new state. It can also return nil to abort the state update, which lets Roact make some handy optimizations. Right now, this version of setState works exactly the same way as the version that accepts an object. In the future, Roact will support optimizations that make this difference more important, like asynchronous rendering . Lifecycle Methods \u00b6 Stateful components can provide methods to Roact that are called when certain things happen to a component instance. Lifecycle methods are a great place to send off network requests, measure UI ( with the help of refs ), wrap non-Roact components, and produce other side-effects. The most useful lifecycle methods are generally didMount and didUpdate . Most components that do things that are difficult to express in Roact itself will use these lifecycle methods. Here's a chart of all of the methods available. You can also check out the Lifecycle Methods section of the API reference for more details. Incrementing Counter, Part Three \u00b6 Building on the previous two examples, we can expand the incrementing counter to move the counter state and loop inside Roact, and use setState to trigger a re-render instead of Roact.reconcile . Generally, this ticking clock demonstrates how many stateful components are structured in Roact. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Roact = require ( ReplicatedStorage . Roact ) local Clock = Roact . Component : extend ( \"Clock\" ) function Clock : init () -- In init, we can use setState to set up our initial component state. self : setState ({ currentTime = 0 }) end -- This render function is almost completely unchanged from the first example. function Clock : render () -- As a convention, we'll pull currentTime out of state right away. local currentTime = self . state . currentTime return Roact . createElement ( \"ScreenGui\" , {}, { TimeLabel = Roact . createElement ( \"TextLabel\" , { Size = UDim2 . new ( 1 , 0 , 1 , 0 ), Text = \"Time Elapsed: \" .. currentTime }) }) end -- Set up our loop in didMount, so that it starts running when our -- component is created. function Clock : didMount () -- Set a value that we can change later to stop our loop self . running = true -- We don't want to block the main thread, so we spawn a new one! spawn ( function () while self . running do -- Because we depend on the previous state, we use the function -- variant of setState. This will matter more when Roact gets -- asynchronous rendering! self : setState ( function ( state ) return { currentTime = state . currentTime + 1 } end ) wait ( 1 ) end end ) end -- Stop the loop in willUnmount, so that our loop terminates when the -- component is destroyed. function Clock : willUnmount () self . running = false end local PlayerGui = Players . LocalPlayer . PlayerGui -- Create our UI, which now runs on its own! local handle = Roact . mount ( Roact . createElement ( Clock ), PlayerGui , \"Clock UI\" ) -- Later, we can destroy our UI and disconnect everything correctly. wait ( 10 ) Roact . unmount ( handle )","title":"State and Lifecycle"},{"location":"guide/state-and-lifecycle/#state","text":"State is the term we use to talk about values that are owned by a component itself. Unlike props , which are passed to a component from above, state is created within a component and can only be updated by that component. We can set up the initial state of a stateful component inside of a method named init : function MyComponent : init () self : setState ({ currentTime = 0 }) end To update state, we use a special method named setState . setState will merge any values we give it into our state. It will overwrite any existing values, and leave any values we don't specify alone. There's another form of setState we can use. When the new state we want our component to have depends on our current state, like incrementing a value, we use this form: -- This is another special method, didMount, that we'll talk about in a moment. function MyComponent : didMount () self : setState ( function ( state ) return { currentTime = currentTime + state . currentTime } end ) end In this case, we're passing a function to setState . This function is called and passed the current state, and returns a new state. It can also return nil to abort the state update, which lets Roact make some handy optimizations. Right now, this version of setState works exactly the same way as the version that accepts an object. In the future, Roact will support optimizations that make this difference more important, like asynchronous rendering .","title":"State"},{"location":"guide/state-and-lifecycle/#lifecycle-methods","text":"Stateful components can provide methods to Roact that are called when certain things happen to a component instance. Lifecycle methods are a great place to send off network requests, measure UI ( with the help of refs ), wrap non-Roact components, and produce other side-effects. The most useful lifecycle methods are generally didMount and didUpdate . Most components that do things that are difficult to express in Roact itself will use these lifecycle methods. Here's a chart of all of the methods available. You can also check out the Lifecycle Methods section of the API reference for more details.","title":"Lifecycle Methods"},{"location":"guide/state-and-lifecycle/#incrementing-counter-part-three","text":"Building on the previous two examples, we can expand the incrementing counter to move the counter state and loop inside Roact, and use setState to trigger a re-render instead of Roact.reconcile . Generally, this ticking clock demonstrates how many stateful components are structured in Roact. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Roact = require ( ReplicatedStorage . Roact ) local Clock = Roact . Component : extend ( \"Clock\" ) function Clock : init () -- In init, we can use setState to set up our initial component state. self : setState ({ currentTime = 0 }) end -- This render function is almost completely unchanged from the first example. function Clock : render () -- As a convention, we'll pull currentTime out of state right away. local currentTime = self . state . currentTime return Roact . createElement ( \"ScreenGui\" , {}, { TimeLabel = Roact . createElement ( \"TextLabel\" , { Size = UDim2 . new ( 1 , 0 , 1 , 0 ), Text = \"Time Elapsed: \" .. currentTime }) }) end -- Set up our loop in didMount, so that it starts running when our -- component is created. function Clock : didMount () -- Set a value that we can change later to stop our loop self . running = true -- We don't want to block the main thread, so we spawn a new one! spawn ( function () while self . running do -- Because we depend on the previous state, we use the function -- variant of setState. This will matter more when Roact gets -- asynchronous rendering! self : setState ( function ( state ) return { currentTime = state . currentTime + 1 } end ) wait ( 1 ) end end ) end -- Stop the loop in willUnmount, so that our loop terminates when the -- component is destroyed. function Clock : willUnmount () self . running = false end local PlayerGui = Players . LocalPlayer . PlayerGui -- Create our UI, which now runs on its own! local handle = Roact . mount ( Roact . createElement ( Clock ), PlayerGui , \"Clock UI\" ) -- Later, we can destroy our UI and disconnect everything correctly. wait ( 10 ) Roact . unmount ( handle )","title":"Incrementing Counter, Part Three"},{"location":"performance/overview/","text":"Roact operates on the principle that it's much easier to build UI declaratively. When something changes, the UI is rebuilt virtually and then the minimal necessary changes are made to the actual UI elements. For simple projects, performance is unlikely to be an issue. But Roact is built in Lua, and Lua can be slow. The following pages provide a number of techniques and best practices that you can employ to avoid performance strain with your Roact apps.","title":"Overview"},{"location":"performance/reduce-reconciliation/","text":"In all likelihood, the primary source of performance gains for your app will come from reducing the amount of work that Roact's reconcilation process requires. This is accomplished by: Indicating to Roact that some reconciliation work can be skipped Making sure your elements only change in ways you intended shouldUpdate Lifecycle Method \u00b6 When a Roact Component's state or props change, it will call the Component's shouldUpdate method to determine whether or not to re-render it. The default implementation will always return true. function Component : shouldUpdate ( newProps , newState ) return true end If you have a more complex component that only needs to re-render in certain situations, you can either use PureComponent (discussed below) or implement your own shouldUpdate and return false in any case where an update is not required. Warning Manually implementing shouldUpdate is dangerous ! If done carelessly, it can easily create confusing or subtle bugs. In most cases, the preferable solution is to use PureComponent instead, which has a simple and robust implementation of shouldUpdate . PureComponent \u00b6 One common implementation of shouldUpdate is to do a shallow comparison between current and previous props and state. Roact provides an extension of Roact.Component called Roact.PureComponent that uses this implementation. Let's use the following example: local Item = Roact . Component : extend ( \"Item\" ) function Item : render () local icon = self . props . icon local layoutOrder = self . props . layoutOrder -- Create a list item with the item's icon and name Roact . createElement ( \"ImageLabel\" , { LayoutOrder = layoutOrder , Image = icon , }) end local Inventory = Roact . Component : extend ( \"Inventory\" ) function Inventory : render () -- An Inventory contains a list of items local items = self . state . items local itemList = {} -- Create a UIListLayout to space out our items itemList [ \"Layout\" ] = Roact . createElement ( \"UIListLayout\" , { SortOrder = Enum . SortOrder . LayoutOrder , FillDirection = Enum . FillDirection . Vertical , }) for i , item in ipairs ( items ) do -- Add the element to our list itemList [ i ] = Roact . createElement ( Item , { layoutOrder = i , icon = item . icon , }) end -- The Inventory renders a frame containing the list of Items as children return Roact . createElement ( \"Frame\" , { Size = UDim2 . new ( 0 , 200 , 0 , 400 ) }, itemList ) end In the above example, adding a new item to the items prop of the Inventory would cause all of the child Item elements to re-render, even if they haven't changed at all. This means if you add an item to an Inventory that already has 5 items, the result will be 6 renders of the Item component. Lets change Item to a PureComponent : local Item = Roact . PureComponent : extend ( \"Item\" ) Now, if we add a new item to the end of the Inventory or change something about an existing item, we'll only re-render the Inventory itself and the modified Item ! Warning When working with PureComponent , it's critical to use immutable props. Immutability guarantees that a prop's reference will change any time its contents change. Info There's more to discuss about immutability. It deserves a fully fleshed-out section somewhere! Stable Keys \u00b6 Another performance improvement we can make is to use stable, unique keys to refer to our child elements. When the list that we pass into the Inventory component changes, Roact reconciles our Roblox UI by adjusting the properties of each primitive according to the new list of elements. For example, let's suppose our list of items is as follows: { { id = \"sword\" , icon = swordIcon }, -- [1] { id = \"shield\" , icon = shieldIcon }, -- [2] } If we add a new item to the beginning, then we'll end up with a list like this: { { id = \"potion\" , icon = potionIcon } -- [1] { id = \"sword\" , icon = swordIcon }, -- [2] { id = \"shield\" , icon = shieldIcon }, -- [3] } When Roact reconciles the underlying ImageLabel objects, it will need to change their icons so that the item at [1] has the potion icon, the item at [2] has the sword icon, and a new ImageLabel is added at [3] with the shield icon. We'd like for Roact to know that the new item was added at [1] and that the sword and sheild items simply moved down in the list. Then it can adjust their LayoutOrder properties and let the Roblox UI system resolve the rest. So let's fix it! We'll make our list of Item elements use the item's id for its keys instead of the indexes in the items list: function Inventory : render () -- An Inventory contains a list of items local items = self . state . items local itemList = {} itemList [ \"Layout\" ] = Roact . createElement ( \"UIListLayout\" , { SortOrder = Enum . SortOrder . LayoutOrder , FillDirection = Enum . FillDirection . Vertical , }) for i , item in ipairs ( items ) do -- Each element is now added at a stable key itemList [ item . id ] = Roact . createElement ( Item , { layoutOrder = i , icon = item . icon , }) end -- The Inventory renders a frame containing the list of Items as children return Roact . createElement ( \"Frame\" , { Size = UDim2 . new ( 0 , 200 , 0 , 400 ) }, itemList ) end Now the list of children is keyed by the stable, unique id of the item data. Their positions can change according to their LayoutOrder, but no other properties on the item need to be reconciled. When we add the third element to the list, Roact will set the LayoutOrder property on for each ImageLabel and only set the Image property on the newly added one! Info Switching to static keys might seem insignificant for this example, but if our Item component becomes more complicated and our inventory gets bigger, it can make a significant difference!","title":"Reduce Reconcilation"},{"location":"performance/reduce-reconciliation/#shouldupdate-lifecycle-method","text":"When a Roact Component's state or props change, it will call the Component's shouldUpdate method to determine whether or not to re-render it. The default implementation will always return true. function Component : shouldUpdate ( newProps , newState ) return true end If you have a more complex component that only needs to re-render in certain situations, you can either use PureComponent (discussed below) or implement your own shouldUpdate and return false in any case where an update is not required. Warning Manually implementing shouldUpdate is dangerous ! If done carelessly, it can easily create confusing or subtle bugs. In most cases, the preferable solution is to use PureComponent instead, which has a simple and robust implementation of shouldUpdate .","title":"shouldUpdate Lifecycle Method"},{"location":"performance/reduce-reconciliation/#purecomponent","text":"One common implementation of shouldUpdate is to do a shallow comparison between current and previous props and state. Roact provides an extension of Roact.Component called Roact.PureComponent that uses this implementation. Let's use the following example: local Item = Roact . Component : extend ( \"Item\" ) function Item : render () local icon = self . props . icon local layoutOrder = self . props . layoutOrder -- Create a list item with the item's icon and name Roact . createElement ( \"ImageLabel\" , { LayoutOrder = layoutOrder , Image = icon , }) end local Inventory = Roact . Component : extend ( \"Inventory\" ) function Inventory : render () -- An Inventory contains a list of items local items = self . state . items local itemList = {} -- Create a UIListLayout to space out our items itemList [ \"Layout\" ] = Roact . createElement ( \"UIListLayout\" , { SortOrder = Enum . SortOrder . LayoutOrder , FillDirection = Enum . FillDirection . Vertical , }) for i , item in ipairs ( items ) do -- Add the element to our list itemList [ i ] = Roact . createElement ( Item , { layoutOrder = i , icon = item . icon , }) end -- The Inventory renders a frame containing the list of Items as children return Roact . createElement ( \"Frame\" , { Size = UDim2 . new ( 0 , 200 , 0 , 400 ) }, itemList ) end In the above example, adding a new item to the items prop of the Inventory would cause all of the child Item elements to re-render, even if they haven't changed at all. This means if you add an item to an Inventory that already has 5 items, the result will be 6 renders of the Item component. Lets change Item to a PureComponent : local Item = Roact . PureComponent : extend ( \"Item\" ) Now, if we add a new item to the end of the Inventory or change something about an existing item, we'll only re-render the Inventory itself and the modified Item ! Warning When working with PureComponent , it's critical to use immutable props. Immutability guarantees that a prop's reference will change any time its contents change. Info There's more to discuss about immutability. It deserves a fully fleshed-out section somewhere!","title":"PureComponent"},{"location":"performance/reduce-reconciliation/#stable-keys","text":"Another performance improvement we can make is to use stable, unique keys to refer to our child elements. When the list that we pass into the Inventory component changes, Roact reconciles our Roblox UI by adjusting the properties of each primitive according to the new list of elements. For example, let's suppose our list of items is as follows: { { id = \"sword\" , icon = swordIcon }, -- [1] { id = \"shield\" , icon = shieldIcon }, -- [2] } If we add a new item to the beginning, then we'll end up with a list like this: { { id = \"potion\" , icon = potionIcon } -- [1] { id = \"sword\" , icon = swordIcon }, -- [2] { id = \"shield\" , icon = shieldIcon }, -- [3] } When Roact reconciles the underlying ImageLabel objects, it will need to change their icons so that the item at [1] has the potion icon, the item at [2] has the sword icon, and a new ImageLabel is added at [3] with the shield icon. We'd like for Roact to know that the new item was added at [1] and that the sword and sheild items simply moved down in the list. Then it can adjust their LayoutOrder properties and let the Roblox UI system resolve the rest. So let's fix it! We'll make our list of Item elements use the item's id for its keys instead of the indexes in the items list: function Inventory : render () -- An Inventory contains a list of items local items = self . state . items local itemList = {} itemList [ \"Layout\" ] = Roact . createElement ( \"UIListLayout\" , { SortOrder = Enum . SortOrder . LayoutOrder , FillDirection = Enum . FillDirection . Vertical , }) for i , item in ipairs ( items ) do -- Each element is now added at a stable key itemList [ item . id ] = Roact . createElement ( Item , { layoutOrder = i , icon = item . icon , }) end -- The Inventory renders a frame containing the list of Items as children return Roact . createElement ( \"Frame\" , { Size = UDim2 . new ( 0 , 200 , 0 , 400 ) }, itemList ) end Now the list of children is keyed by the stable, unique id of the item data. Their positions can change according to their LayoutOrder, but no other properties on the item need to be reconciled. When we add the third element to the list, Roact will set the LayoutOrder property on for each ImageLabel and only set the Image property on the newly added one! Info Switching to static keys might seem insignificant for this example, but if our Item component becomes more complicated and our inventory gets bigger, it can make a significant difference!","title":"Stable Keys"}]}