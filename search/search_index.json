{
    "docs": [
        {
            "location": "/",
            "text": "Roact is a \ndeclarative\n Lua UI library similar to Facebook's \nReact\n. It exposes a very similar API and implements nearly identical semantics.\n\n\nThis documentation is based on the structure of React's documentation, but is a work in progress. Many things from React also apply to Roact, but if you find anything missing or incorrect, \nopen an issue on GitHub\n!\n\n\n\n\nInfo\n\n\nThis documentation assumes some familiarity with Lua. If you're new to Lua, \nProgramming in Lua\n by Roberto Ierusalimschy\n is a good introduction, and the first edition (for Lua 5.0) is available online for free.",
            "title": "Home"
        },
        {
            "location": "/guide/installation/",
            "text": "There are two supported ways to get started with Roact.\n\n\nFor our examples, we'll install \nRoact\n to \nReplicatedStorage\n. In practice, it's okay to install Roact anywhere you want!\n\n\nMethod 1: Model File (Roblox Studio)\n\u00b6\n\n\n\n\nDownload the \nrbxmx\n model file attached to the latest release from the \nGitHub releases page\n.\n\n\nInsert the model into Studio into a place like \nReplicatedStorage\n\n\n\n\nMethod 2: Filesystem\n\u00b6\n\n\n\n\nCopy the \nlib\n directory into your codebase\n\n\nRename the folder to \nRoact\n\n\nUse a plugin like \nRojo\n to sync the files into a place",
            "title": "Installation"
        },
        {
            "location": "/guide/installation/#method-1-model-file-roblox-studio",
            "text": "Download the  rbxmx  model file attached to the latest release from the  GitHub releases page .  Insert the model into Studio into a place like  ReplicatedStorage",
            "title": "Method 1: Model File (Roblox Studio)"
        },
        {
            "location": "/guide/installation/#method-2-filesystem",
            "text": "Copy the  lib  directory into your codebase  Rename the folder to  Roact  Use a plugin like  Rojo  to sync the files into a place",
            "title": "Method 2: Filesystem"
        },
        {
            "location": "/guide/hello-roact/",
            "text": "Info\n\n\nThese examples asssumes that you've successfully \ninstalled Roact\n into \nReplicatedStorage\n!\n\n\n\n\nAdd a new \nLocalScript\n object to \nStarterPlayer.StarterPlayerScripts\n either in Roblox Studio, or via Rojo:\n\n\nlocal\n \nReplicatedStorage\n \n=\n \ngame\n:\nGetService\n(\n\"ReplicatedStorage\"\n)\n\n\nlocal\n \nPlayers\n \n=\n \ngame\n:\nGetService\n(\n\"Players\"\n)\n\n\n\nlocal\n \nRoact\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRoact\n)\n\n\n\nlocal\n \napp\n \n=\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \n{},\n \n{\n\n    \nHelloWorld\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n400\n,\n \n0\n,\n \n300\n),\n\n        \nText\n \n=\n \n\"Hello, Roact!\"\n\n    \n})\n\n\n})\n\n\n\nRoact\n.\nmount\n(\napp\n,\n \nPlayers\n.\nLocalPlayer\n.\nPlayerGui\n)\n\n\n\n\n\nWhen you run your game, you should see a large gray label with the phrase 'Hello, Roact!' appear on screen!",
            "title": "Hello, Roact!"
        },
        {
            "location": "/guide/elements/",
            "text": "Like React, everything in Roact is built out of elements. Elements are the smallest building blocks for creating UI.\n\n\nElements describe what you want your UI to look like at a single point in time. They're \nimmutable\n: you can't change elements once they're created, but you can create new ones. Because creating elements is fast, this is no big deal.\n\n\nYou can create an element using \nRoact.createElement\n -- just pass a Roblox class name as the first argument, and any properties as the second argument!\n\n\nlocal\n \nmyElement\n \n=\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n    \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n50\n,\n \n0\n,\n \n50\n)\n\n\n})\n\n\n\n\n\nYou can also represent children by passing them to the optional third argument of \ncreateElement\n:\n\n\nlocal\n \nmyElement\n \n=\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n    \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n50\n,\n \n0\n,\n \n50\n)\n\n\n},\n \n{\n\n    \nSomeChild\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \n\"Hello, Roact!\"\n\n    \n})\n\n\n})\n\n\n\n\n\nCreating an element by itself doesn't do anything, however. In order to turn our description of an object into a real Roblox Instance, we can call \nRoact.mount\n:\n\n\n-- Create a new Frame object in 'Workspace'\n\n\nlocal\n \nmyHandle\n \n=\n \nRoact\n.\nmount\n(\nmyElement\n,\n \ngame\n.\nWorkspace\n)\n\n\n\n\n\nMounting is the process of creating a Roact component instance as well as any associated Roblox Instances.\n\n\nRoact.mount\n returns a handle that we can later use to update or destroy that object with \nRoact.reconcile\n and \nRoact.unmount\n.\n\n\nChanging What's Rendered\n\u00b6\n\n\nIn order to change the UI that we've created, we need to create a new set of elements and \nreconcile\n the existing tree to match it.\n\n\nReconciliation is the term that Roact uses to describe the process of updating an existing UI to match what the program wants it to look like at any given time.\n\n\nUsing \nmyHandle\n from above, we can update the size and text of our label:\n\n\n-- Make some new elements that describe what our new UI will look like.\n\n\nlocal\n \nmyNewElement\n \n=\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n    \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n100\n,\n \n0\n,\n \n50\n)\n\n\n},\n \n{\n\n    \nSomeChild\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \n\"Hello, again, Roact!\"\n\n    \n})\n\n\n})\n\n\n\n-- Update our hierarchy to match those elements.\n\n\nmyHandle\n \n=\n \nRoact\n.\nreconcile\n(\nmyHandle\n,\n \nmyNewElement\n)\n\n\n\n\n\n\n\nInfo\n\n\nMost projects using UI don't use \nRoact.reconcile\n and instead change UI using state and lifecycle events, which will be introduced in the next section.\n\n\nRoact.reconcile\n is mostly useful to embed Roact components into existing, non-Roact projects, and for introducing Roact!\n\n\n\n\nUnlike many other UI systems, Roact doesn't let you directly set values on UI objects. Instead, describe what your UI should look like in the form of elements and Roact will handle changing the underlying Roblox Instances.\n\n\nUnmounting the Tree\n\u00b6\n\n\nRoact provides a method called \nRoact.unmount\n that we can use when we're finished with our tree.\n\n\nRoact\n.\nunmount\n(\nmyHandle\n)\n\n\n\n\n\nUnmounting destructs the given Roact component instance and destroys any associated Roblox Instances with it.\n\n\n\n\nWarning\n\n\nTrying to use a handle after it's been passed to \nRoact.unmount\n will result in errors!\n\n\n\n\nIncrementing Counter\n\u00b6\n\n\nUsing what's been covered so far, we can make a simple program that tells you how long it has been running.\n\n\nThis is a complete example that should work when put into a \nLocalScript\n in \nStarterPlayerScripts\n. It assumes Roact has been installed into \nReplicatedStorage\n.\n\n\nlocal\n \nReplicatedStorage\n \n=\n \ngame\n:\nGetService\n(\n\"ReplicatedStorage\"\n)\n\n\nlocal\n \nPlayers\n \n=\n \ngame\n:\nGetService\n(\n\"Players\"\n)\n\n\n\nlocal\n \nRoact\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRoact\n)\n\n\n\n-- Create a function that creates the elements for our UI.\n\n\n-- Later, we'll use components, which are the best way to organize UI in Roact.\n\n\nlocal\n \nfunction\n \nclock\n(\ncurrentTime\n)\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \n{},\n \n{\n\n        \nTimeLabel\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n            \nSize\n \n=\n \nUDim2\n.\nnew\n(\n1\n,\n \n0\n,\n \n1\n,\n \n0\n),\n\n            \nText\n \n=\n \n\"Time Elapsed: \"\n \n..\n \ncurrentTime\n\n        \n})\n\n    \n})\n\n\nend\n\n\n\nlocal\n \nPlayerGui\n \n=\n \nPlayers\n.\nLocalPlayer\n.\nPlayerGui\n\n\n\n-- Create our initial UI.\n\n\nlocal\n \ncurrentTime\n \n=\n \n0\n\n\nlocal\n \nhandle\n \n=\n \nRoact\n.\nmount\n(\nclock\n(\ncurrentTime\n),\n \nPlayerGui\n,\n \n\"Clock UI\"\n)\n\n\n\n-- Every second, update the UI to show our new time.\n\n\nwhile\n \ntrue\n \ndo\n\n    \nwait\n(\n1\n)\n\n\n    \ncurrentTime\n \n=\n \ncurrentTime\n \n+\n \n1\n\n    \nhandle\n \n=\n \nRoact\n.\nreconcile\n(\nhandle\n,\n \nclock\n(\ncurrentTime\n))\n\n\nend\n\n\n\n\n\nIn the next section, we'll talk about components, which let us create reusable chunks of UI, and introduce the primary technique to change UI in Roact.",
            "title": "Elements"
        },
        {
            "location": "/guide/elements/#changing-whats-rendered",
            "text": "In order to change the UI that we've created, we need to create a new set of elements and  reconcile  the existing tree to match it.  Reconciliation is the term that Roact uses to describe the process of updating an existing UI to match what the program wants it to look like at any given time.  Using  myHandle  from above, we can update the size and text of our label:  -- Make some new elements that describe what our new UI will look like.  local   myNewElement   =   Roact . createElement ( \"Frame\" ,   { \n     Size   =   UDim2 . new ( 0 ,   100 ,   0 ,   50 )  },   { \n     SomeChild   =   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   \"Hello, again, Roact!\" \n     })  })  -- Update our hierarchy to match those elements.  myHandle   =   Roact . reconcile ( myHandle ,   myNewElement )    Info  Most projects using UI don't use  Roact.reconcile  and instead change UI using state and lifecycle events, which will be introduced in the next section.  Roact.reconcile  is mostly useful to embed Roact components into existing, non-Roact projects, and for introducing Roact!   Unlike many other UI systems, Roact doesn't let you directly set values on UI objects. Instead, describe what your UI should look like in the form of elements and Roact will handle changing the underlying Roblox Instances.",
            "title": "Changing What's Rendered"
        },
        {
            "location": "/guide/elements/#unmounting-the-tree",
            "text": "Roact provides a method called  Roact.unmount  that we can use when we're finished with our tree.  Roact . unmount ( myHandle )   Unmounting destructs the given Roact component instance and destroys any associated Roblox Instances with it.   Warning  Trying to use a handle after it's been passed to  Roact.unmount  will result in errors!",
            "title": "Unmounting the Tree"
        },
        {
            "location": "/guide/elements/#incrementing-counter",
            "text": "Using what's been covered so far, we can make a simple program that tells you how long it has been running.  This is a complete example that should work when put into a  LocalScript  in  StarterPlayerScripts . It assumes Roact has been installed into  ReplicatedStorage .  local   ReplicatedStorage   =   game : GetService ( \"ReplicatedStorage\" )  local   Players   =   game : GetService ( \"Players\" )  local   Roact   =   require ( ReplicatedStorage . Roact )  -- Create a function that creates the elements for our UI.  -- Later, we'll use components, which are the best way to organize UI in Roact.  local   function   clock ( currentTime ) \n     return   Roact . createElement ( \"ScreenGui\" ,   {},   { \n         TimeLabel   =   Roact . createElement ( \"TextLabel\" ,   { \n             Size   =   UDim2 . new ( 1 ,   0 ,   1 ,   0 ), \n             Text   =   \"Time Elapsed: \"   ..   currentTime \n         }) \n     })  end  local   PlayerGui   =   Players . LocalPlayer . PlayerGui  -- Create our initial UI.  local   currentTime   =   0  local   handle   =   Roact . mount ( clock ( currentTime ),   PlayerGui ,   \"Clock UI\" )  -- Every second, update the UI to show our new time.  while   true   do \n     wait ( 1 ) \n\n     currentTime   =   currentTime   +   1 \n     handle   =   Roact . reconcile ( handle ,   clock ( currentTime ))  end   In the next section, we'll talk about components, which let us create reusable chunks of UI, and introduce the primary technique to change UI in Roact.",
            "title": "Incrementing Counter"
        },
        {
            "location": "/guide/components/",
            "text": "Components are encapsulated, reusable pieces of UI that you can combine to build a complete UI.\n\n\nComponents accept inputs, known as \nprops\n, and return elements to describe the UI that should represent those inputs.\n\n\nFunctional and Stateful Components\n\u00b6\n\n\nComponents come in two flavors in Roact, \nfunctional\n and \nstateful\n.\n\n\nFunctional components are the simplest: they're just functions that accept props as their only argument, and return some elements.\n\n\nlocal\n \nfunction\n \nGreeting\n(\nprops\n)\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \n\"Hello, \"\n \n..\n \nprops\n.\nname\n\n    \n})\n\n\nend\n\n\n\n\n\nRoact also has \nstateful\n components, which have additional features, like lifecycle methods and state, that we'll talk about in a later section.\n\n\nYou can create a stateful component by calling \nRoact.Component:extend\n and passing in the component's name.\n\n\nlocal\n \nGreeting\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"Greeting\"\n)\n\n\n\nfunction\n \nGreeting\n:\nrender\n()\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \n\"Hello, \"\n \n..\n \nself\n.\nprops\n.\nname\n\n    \n})\n\n\nend\n\n\n\n\n\nUsing Components\n\u00b6\n\n\nIn our previous examples, we passed strings to \nRoact.createElement\n to create elements that represented Roblox Instances.\n\n\nWe can also pass our custom components to create elements that represent them:\n\n\nlocal\n \nhello\n \n=\n \nRoact\n.\ncreateElement\n(\nGreeting\n,\n \n{\n\n    \nname\n \n=\n \n\"Rick James\"\n\n\n})\n\n\n\n\n\nThe \nname\n value is passed to our component as props, which we can reference as the \nprops\n argument in our functional component or \nself.props\n in our stateful component.\n\n\nComponents in Components\n\u00b6\n\n\nComponents are designed to make it easy to re-use pieces of UI, so naturally, we can use components inside other components!\n\n\nlocal\n \nfunction\n \nGreeting\n(\nprops\n)\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \n\"Hello, \"\n \n..\n \nprops\n.\nname\n\n    \n})\n\n\nend\n\n\n\nlocal\n \nfunction\n \nGreetEveryone\n()\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \n{\n\n        \nLayout\n \n=\n \nRoact\n.\ncreateElement\n(\n\"UIListLayout\"\n),\n\n\n        \nHelloJoe\n \n=\n \nRoact\n.\ncreateElement\n(\nGreeting\n,\n \n{\n\n            \nname\n \n=\n \n\"Joe\"\n\n        \n}),\n\n\n        \nHelloMary\n \n=\n \nRoact\n.\ncreateElement\n(\nGreeting\n,\n \n{\n\n            \nname\n \n=\n \n\"Mary\"\n\n        \n})\n\n    \n})\n\n\nend\n\n\n\n\n\nApplications built using Roact usually have one component at the top of the tree, and include all other pieces as children.\n\n\nIncrementing Counter, Part Two\n\u00b6\n\n\nWe can revisit the incrementing counter example from the previous section, now using a functional component. Changed sections are highlighted.\n\n\nlocal\n \nReplicatedStorage\n \n=\n \ngame\n:\nGetService\n(\n\"ReplicatedStorage\"\n)\n\n\nlocal\n \nPlayers\n \n=\n \ngame\n:\nGetService\n(\n\"Players\"\n)\n\n\n\nlocal\n \nRoact\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRoact\n)\n\n\n\n-- Create a functional component that represents our UI\n\n\nlocal\n \nfunction\n \nClock\n(\nprops\n)\n\n\n    \nlocal\n \ncurrentTime\n \n=\n \nprops\n.\ncurrentTime\n\n\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \n{},\n \n{\n\n        \nTimeLabel\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n            \nSize\n \n=\n \nUDim2\n.\nnew\n(\n1\n,\n \n0\n,\n \n1\n,\n \n0\n),\n\n            \nText\n \n=\n \n\"Time Elapsed: \"\n \n..\n \ncurrentTime\n\n        \n})\n\n    \n})\n\n\nend\n\n\n\nlocal\n \nPlayerGui\n \n=\n \nPlayers\n.\nLocalPlayer\n.\nPlayerGui\n\n\n\n-- Create our initial UI.\n\n\nlocal\n \ncurrentTime\n \n=\n \n0\n\n\n\nlocal\n \nclockElement\n \n=\n \nRoact\n.\ncreateElement\n(\nClock\n,\n \n{\n\n\n    \ncurrentTime\n \n=\n \ncurrentTime\n\n\n})\n\n\nlocal\n \nhandle\n \n=\n \nRoact\n.\nmount\n(\nclockElement\n,\n \nPlayerGui\n,\n \n\"Clock UI\"\n)\n\n\n\n\n-- Every second, update the UI to show our new time.\n\n\nwhile\n \ntrue\n \ndo\n\n    \nwait\n(\n1\n)\n\n\n    \ncurrentTime\n \n=\n \ncurrentTime\n \n+\n \n1\n\n\n    \nhandle\n \n=\n \nRoact\n.\nreconcile\n(\nhandle\n,\n \nRoact\n.\ncreateElement\n(\nClock\n,\n \n{\n\n\n        \ncurrentTime\n \n=\n \ncurrentTime\n\n\n    \n}))\n\n\nend",
            "title": "Components"
        },
        {
            "location": "/guide/components/#functional-and-stateful-components",
            "text": "Components come in two flavors in Roact,  functional  and  stateful .  Functional components are the simplest: they're just functions that accept props as their only argument, and return some elements.  local   function   Greeting ( props ) \n     return   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   \"Hello, \"   ..   props . name \n     })  end   Roact also has  stateful  components, which have additional features, like lifecycle methods and state, that we'll talk about in a later section.  You can create a stateful component by calling  Roact.Component:extend  and passing in the component's name.  local   Greeting   =   Roact . Component : extend ( \"Greeting\" )  function   Greeting : render () \n     return   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   \"Hello, \"   ..   self . props . name \n     })  end",
            "title": "Functional and Stateful Components"
        },
        {
            "location": "/guide/components/#using-components",
            "text": "In our previous examples, we passed strings to  Roact.createElement  to create elements that represented Roblox Instances.  We can also pass our custom components to create elements that represent them:  local   hello   =   Roact . createElement ( Greeting ,   { \n     name   =   \"Rick James\"  })   The  name  value is passed to our component as props, which we can reference as the  props  argument in our functional component or  self.props  in our stateful component.",
            "title": "Using Components"
        },
        {
            "location": "/guide/components/#components-in-components",
            "text": "Components are designed to make it easy to re-use pieces of UI, so naturally, we can use components inside other components!  local   function   Greeting ( props ) \n     return   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   \"Hello, \"   ..   props . name \n     })  end  local   function   GreetEveryone () \n     return   Roact . createElement ( \"ScreenGui\" ,   { \n         Layout   =   Roact . createElement ( \"UIListLayout\" ), \n\n         HelloJoe   =   Roact . createElement ( Greeting ,   { \n             name   =   \"Joe\" \n         }), \n\n         HelloMary   =   Roact . createElement ( Greeting ,   { \n             name   =   \"Mary\" \n         }) \n     })  end   Applications built using Roact usually have one component at the top of the tree, and include all other pieces as children.",
            "title": "Components in Components"
        },
        {
            "location": "/guide/components/#incrementing-counter-part-two",
            "text": "We can revisit the incrementing counter example from the previous section, now using a functional component. Changed sections are highlighted.  local   ReplicatedStorage   =   game : GetService ( \"ReplicatedStorage\" )  local   Players   =   game : GetService ( \"Players\" )  local   Roact   =   require ( ReplicatedStorage . Roact )  -- Create a functional component that represents our UI  local   function   Clock ( props )       local   currentTime   =   props . currentTime  \n     return   Roact . createElement ( \"ScreenGui\" ,   {},   { \n         TimeLabel   =   Roact . createElement ( \"TextLabel\" ,   { \n             Size   =   UDim2 . new ( 1 ,   0 ,   1 ,   0 ), \n             Text   =   \"Time Elapsed: \"   ..   currentTime \n         }) \n     })  end  local   PlayerGui   =   Players . LocalPlayer . PlayerGui  -- Create our initial UI.  local   currentTime   =   0  local   clockElement   =   Roact . createElement ( Clock ,   {       currentTime   =   currentTime  })  local   handle   =   Roact . mount ( clockElement ,   PlayerGui ,   \"Clock UI\" )   -- Every second, update the UI to show our new time.  while   true   do \n     wait ( 1 ) \n\n     currentTime   =   currentTime   +   1       handle   =   Roact . reconcile ( handle ,   Roact . createElement ( Clock ,   {           currentTime   =   currentTime       }))  end",
            "title": "Incrementing Counter, Part Two"
        },
        {
            "location": "/guide/state-and-lifecycle/",
            "text": "In the previous section, we talked about using components to create reusable chunks of state, and introduced \nfunctional\n and \nstateful\n components.\n\n\nStateful components do everything that functional components do, but have the addition of mutable \nstate\n and \nlifecycle methods\n.\n\n\nState\n\u00b6\n\n\n\n\nInfo\n\n\nThis section is incomplete!\n\n\n\n\nLifecycle Methods\n\u00b6\n\n\nStateful components can provide methods to Roact that are called when certain things happen to a component instance.\n\n\nLifecycle methods are a great place to send off network requests, measure UI (\nwith the help of refs\n), wrap non-Roact components, and produce other side-effects.\n\n\n\n    \n\n        \n\n    \n\n\n\n\n\nIncrementing Counter, Part Three\n\u00b6\n\n\nBuilding on the previous two examples, we can expand the incrementing counter to move the counter state and loop inside Roact, and use \nsetState\n to trigger a re-render instead of \nRoact.reconcile\n.\n\n\nGenerally, this ticking clock demonstrates how many stateful components are structured in Roact.\n\n\nlocal\n \nReplicatedStorage\n \n=\n \ngame\n:\nGetService\n(\n\"ReplicatedStorage\"\n)\n\n\nlocal\n \nPlayers\n \n=\n \ngame\n:\nGetService\n(\n\"Players\"\n)\n\n\n\nlocal\n \nRoact\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRoact\n)\n\n\n\nlocal\n \nClock\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"Clock\"\n)\n\n\n\nfunction\n \nClock\n:\ninit\n()\n\n    \n-- In init, you should assign to 'state' directly.\n\n    \n-- Use this opportunity to set any initial values.\n\n    \nself\n.\nstate\n \n=\n \n{\n\n        \ncurrentTime\n \n=\n \n0\n\n    \n}\n\n\nend\n\n\n\n-- This render function is almost completely unchanged from the first example.\n\n\nfunction\n \nClock\n:\nrender\n()\n\n    \n-- As a convention, we'll pull currentTime out of state right away.\n\n    \nlocal\n \ncurrentTime\n \n=\n \nself\n.\nstate\n.\ncurrentTime\n\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \n{},\n \n{\n\n        \nTimeLabel\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n            \nSize\n \n=\n \nUDim2\n.\nnew\n(\n1\n,\n \n0\n,\n \n1\n,\n \n0\n),\n\n            \nText\n \n=\n \n\"Time Elapsed: \"\n \n..\n \ncurrentTime\n\n        \n})\n\n    \n})\n\n\nend\n\n\n\n-- Set up our loop in didMount, so that it starts running when our\n\n\n-- component is created.\n\n\nfunction\n \nClock\n:\ndidMount\n()\n\n    \n-- Set a value that we can change later to stop our loop\n\n    \nself\n.\nrunning\n \n=\n \ntrue\n\n\n    \n-- We don't want to block the main thread, so we spawn a new one!\n\n    \nspawn\n(\nfunction\n()\n\n        \nwhile\n \nself\n.\nrunning\n \ndo\n\n            \n-- Because we depend on the previous state, we use the function\n\n            \n-- variant of setState. This will matter more when Roact gets\n\n            \n-- asynchronous rendering!\n\n            \nself\n:\nsetState\n(\nfunction\n(\nstate\n)\n\n                \nreturn\n \n{\n\n                    \ncurrentTime\n \n=\n \nstate\n.\ncurrentTime\n \n+\n \n1\n\n                \n}\n\n            \nend\n)\n\n\n            \nwait\n(\n1\n)\n\n        \nend\n\n    \nend\n)\n\n\nend\n\n\n\n-- Stop the loop in willUnmount, so that our loop terminates when the\n\n\n-- component is destroyed.\n\n\nfunction\n \nClock\n:\nwillUnmount\n()\n\n    \nself\n.\nrunning\n \n=\n \nfalse\n\n\nend\n\n\n\nlocal\n \nPlayerGui\n \n=\n \nPlayers\n.\nLocalPlayer\n.\nPlayerGui\n\n\n\n-- Create our UI, which now runs on its own!\n\n\nlocal\n \nhandle\n \n=\n \nRoact\n.\nmount\n(\nRoact\n.\ncreateElement\n(\nClock\n),\n \nPlayerGui\n,\n \n\"Clock UI\"\n)\n\n\n\n-- Later, we can destroy our UI and disconnect everything correctly.\n\n\nwait\n(\n10\n)\n\n\nRoact\n.\nunmount\n(\nhandle\n)",
            "title": "State and Lifecycle"
        },
        {
            "location": "/guide/state-and-lifecycle/#state",
            "text": "Info  This section is incomplete!",
            "title": "State"
        },
        {
            "location": "/guide/state-and-lifecycle/#lifecycle-methods",
            "text": "Stateful components can provide methods to Roact that are called when certain things happen to a component instance.  Lifecycle methods are a great place to send off network requests, measure UI ( with the help of refs ), wrap non-Roact components, and produce other side-effects.",
            "title": "Lifecycle Methods"
        },
        {
            "location": "/guide/state-and-lifecycle/#incrementing-counter-part-three",
            "text": "Building on the previous two examples, we can expand the incrementing counter to move the counter state and loop inside Roact, and use  setState  to trigger a re-render instead of  Roact.reconcile .  Generally, this ticking clock demonstrates how many stateful components are structured in Roact.  local   ReplicatedStorage   =   game : GetService ( \"ReplicatedStorage\" )  local   Players   =   game : GetService ( \"Players\" )  local   Roact   =   require ( ReplicatedStorage . Roact )  local   Clock   =   Roact . Component : extend ( \"Clock\" )  function   Clock : init () \n     -- In init, you should assign to 'state' directly. \n     -- Use this opportunity to set any initial values. \n     self . state   =   { \n         currentTime   =   0 \n     }  end  -- This render function is almost completely unchanged from the first example.  function   Clock : render () \n     -- As a convention, we'll pull currentTime out of state right away. \n     local   currentTime   =   self . state . currentTime \n\n     return   Roact . createElement ( \"ScreenGui\" ,   {},   { \n         TimeLabel   =   Roact . createElement ( \"TextLabel\" ,   { \n             Size   =   UDim2 . new ( 1 ,   0 ,   1 ,   0 ), \n             Text   =   \"Time Elapsed: \"   ..   currentTime \n         }) \n     })  end  -- Set up our loop in didMount, so that it starts running when our  -- component is created.  function   Clock : didMount () \n     -- Set a value that we can change later to stop our loop \n     self . running   =   true \n\n     -- We don't want to block the main thread, so we spawn a new one! \n     spawn ( function () \n         while   self . running   do \n             -- Because we depend on the previous state, we use the function \n             -- variant of setState. This will matter more when Roact gets \n             -- asynchronous rendering! \n             self : setState ( function ( state ) \n                 return   { \n                     currentTime   =   state . currentTime   +   1 \n                 } \n             end ) \n\n             wait ( 1 ) \n         end \n     end )  end  -- Stop the loop in willUnmount, so that our loop terminates when the  -- component is destroyed.  function   Clock : willUnmount () \n     self . running   =   false  end  local   PlayerGui   =   Players . LocalPlayer . PlayerGui  -- Create our UI, which now runs on its own!  local   handle   =   Roact . mount ( Roact . createElement ( Clock ),   PlayerGui ,   \"Clock UI\" )  -- Later, we can destroy our UI and disconnect everything correctly.  wait ( 10 )  Roact . unmount ( handle )",
            "title": "Incrementing Counter, Part Three"
        },
        {
            "location": "/guide/events/",
            "text": "Roact manages Instance event connections automatically as part of rendering.\n\n\nTo connect to an event, pass a prop with \nRoact.Event.EVENT_NAME\n as the key and a function as the value.\n\n\nRoact will pass the instance that the event is connected to as the first argument to the event callback, followed by any arguments that Roblox passed in.\n\n\nlocal\n \nbutton\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextButton\"\n,\n \n{\n\n    \nText\n \n=\n \n\"Click me!\"\n,\n\n    \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n400\n,\n \n0\n,\n \n300\n),\n\n\n    \n[\nRoact\n.\nEvent\n.\nMouseButton1Click\n]\n \n=\n \nfunction\n(\nrbx\n)\n\n        \nprint\n(\n\"The button was clicked!\"\n)\n\n    \nend\n\n\n})\n\n\n\n\n\n\n\nInfo\n\n\nEvents will automatically be disconnected when a component instance is unmounted!\n\n\n\n\nTo listen to \nGetPropertyChangedSignal\n, Roact provides a similar API, using props like \nRoact.Change.PROPERTY_NAME\n:\n\n\nlocal\n \nframe\n \n=\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n    \n[\nRoact\n.\nChange\n.\nAbsoluteSize\n]\n \n=\n \nfunction\n(\nrbx\n)\n\n        \nprint\n(\n\"Absolute size changed to\"\n,\n \nrbx\n.\nAbsoluteSize\n)\n\n    \nend\n\n\n})\n\n\n\n\n\n\n\nWarning\n\n\nRoact can trigger events while updating the tree! If Roact triggers an event handler that calls \nsetState\n synchronously, an error will be thrown. In the future, Roact may delay evaluation of event handlers to prevent them from happening while Roact is modifying the tree.",
            "title": "Events"
        },
        {
            "location": "/advanced/portals/",
            "text": "Portals\n are a special kind of component provided by Roact that enable components to render objects into a separate, non-Roact Instance.\n\n\n\n\nInfo\n\n\nEventually, there will be a diagram of Roact portals here. For now, just imagine Valve's hit game, \nPortal\n.\n\n\n\n\nTo create a portal, use the \nRoact.Portal\n component with \ncreateElement\n:\n\n\nlocal\n \nfunction\n \nPartInWorkspace\n(\nprops\n)\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\nRoact\n.\nPortal\n,\n \n{\n\n        \ntarget\n \n=\n \nWorkspace\n\n    \n},\n \n{\n\n        \nSomePart\n \n=\n \nRoact\n.\ncreateElement\n(\n\"Part\"\n,\n \n{\n\n            \nAnchored\n \n=\n \ntrue\n\n        \n})\n\n    \n})\n\n\nend\n\n\n\n\n\nWhen we create \nPartInWorkspace\n, even if it's deep into our Roact tree, a \nPart\n Instance named \nSomePart\n will be created in \nWorkspace\n.\n\n\n\n\nWarning\n\n\nPortals should only be created to objects that aren't managed by Roact!\n\n\n\n\nOne particularly good use for portals is full-screen modal dialogs. When we render a modal dialog, we want it to take over the entire screen, but we want components deep in the tree to be able to create them!\n\n\nlocal\n \nPlayerGui\n \n=\n \ngame\n:\nGetService\n(\n\"Players\"\n).\nLocalPlayer\n.\nPlayerGui\n\n\n\n-- Our Modal component is a standard component, but with a portal at the top!\n\n\nlocal\n \nfunction\n \nModal\n(\nprops\n)\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\nRoact\n.\nPortal\n,\n \n{\n\n        \ntarget\n \n=\n \nPlayerGui\n\n    \n},\n \n{\n\n        \nModal\n \n=\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \n{},\n \n{\n\n            \nLabel\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextButton\"\n,\n \n{\n\n                \nSize\n \n=\n \nUDim2\n.\nnew\n(\n1\n,\n \n0\n,\n \n1\n,\n \n0\n),\n\n                \nText\n \n=\n \n\"Click me to close!\"\n,\n\n\n                \n[\nRoact\n.\nEvent\n.\nActivated\n]\n \n=\n \nfunction\n()\n\n                    \nprops\n.\nonClose\n()\n\n                \nend\n\n            \n})\n\n        \n})\n\n    \n})\n\n\nend\n\n\n\n-- A ModalButton contains a little bit of state to decide whether the dialog\n\n\n-- should be open or not.\n\n\nlocal\n \nModalButton\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"ModalButton\"\n)\n\n\n\nfunction\n \nModalButton\n:\ninit\n()\n\n    \nself\n.\nstate\n \n=\n \n{\n\n        \ndialogOpen\n \n=\n \nfalse\n\n    \n}\n\n\nend\n\n\n\nfunction\n \nModalButton\n:\nrender\n()\n\n    \nlocal\n \ndialog\n \n=\n \nnil\n\n\n    \n-- If the dialog isn't open, just avoid rendering it.\n\n    \nif\n \nself\n.\nstate\n.\ndialogOpen\n \nthen\n\n        \ndialog\n \n=\n \nRoact\n.\ncreateElement\n(\nModal\n,\n \n{\n\n            \nonClose\n \n=\n \nfunction\n()\n\n                \nself\n:\nsetState\n({\n\n                    \ndialogOpen\n \n=\n \nfalse\n\n                \n})\n\n            \nend\n\n        \n})\n\n    \nend\n\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextButton\"\n,\n \n{\n\n        \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n400\n,\n \n0\n,\n \n300\n),\n\n        \nText\n \n=\n \n\"Click me to open modal dialog!\"\n,\n\n\n        \n[\nRoact\n.\nEvent\n.\nActivated\n]\n \n=\n \nfunction\n()\n\n            \nself\n:\nsetState\n({\n\n                \ndialogOpen\n \n=\n \ntrue\n\n            \n})\n\n        \nend\n\n    \n},\n \n{\n\n        \n-- If `dialog` ends up nil, this line does nothing!\n\n        \nDialog\n \n=\n \ndialog\n\n    \n})\n\n\nend",
            "title": "Portals"
        },
        {
            "location": "/advanced/refs/",
            "text": "Refs\n grant access to the actual Instance objects that are created by Roact. They're an escape hatch for when something is difficult or impossible to correctly express with the Roact API.\n\n\n\n\nInfo\n\n\nRefs can only be used with primitive components.\n\n\n\n\nRefs in Action\n\u00b6\n\n\nTo create a ref, pass a function prop with the key \nRoact.Ref\n when creating a primitive element.\n\n\nFor example, suppose we wanted to create a search bar that captured cursor focus when any part of it was clicked. We might use a component like this:\n\n\n--[[\n\n\n    A search bar with an icon and a text box that captures focus for its TextBox\n\n\n    when its icon is clicked\n\n\n ]]\n\n\nlocal\n \nSearchBar\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"SearchBar\"\n)\n\n\n\nfunction\n \nSearchBar\n:\ninit\n()\n\n    \nself\n.\ntextBoxRef\n \n=\n \nRoact\n.\ncreateRef\n()\n\n\nend\n\n\n\nfunction\n \nSearchBar\n:\nrender\n()\n\n    \n-- Render our icon and text box side by side in a Frame\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n        \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n200\n,\n \n0\n,\n \n20\n),\n\n    \n},\n \n{\n\n        \nSearchIcon\n \n=\n \nRoact\n.\ncreateElement\n(\n\"ImageButton\"\n,\n \n{\n\n            \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n20\n,\n \n0\n,\n \n20\n),\n\n\n            \n-- Handle click events on the icon\n\n            \n[\nRoact\n.\nEvent\n.\nActivated\n]\n \n=\n \nfunction\n()\n\n                \nself\n.\ntextBoxRef\n.\ncurrent\n:\nCaptureFocus\n()\n\n            \nend\n\n        \n}),\n\n\n        \nSearchTextBox\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextBox\"\n,\n \n{\n\n            \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n180\n,\n \n0\n,\n \n20\n),\n\n            \nPosition\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n20\n,\n \n0\n,\n \n0\n),\n\n\n            \n-- Use Roact.Ref to get a reference to the underlying object\n\n            \n[\nRoact\n.\nRef\n]\n \n=\n \nself\n.\ntextBoxRef\n\n        \n}),\n\n    \n})\n\n\nend\n\n\n\nWhen a user clicks on the outer \nImageButton\n, the \ncaptureTextboxFocus\n callback will be triggered and the \nTextBox\n instance will get focus as if it had been clicked on directly.\n\n\nRefs During Unmount\n\u00b6\n\n\n\n\nWarning\n\n\nWhen using the function version of refs, any time a component instance is destroyed or the ref property changes, \nnil\n will be passed to the old ref function!\n\n\n\n\nlocal\n \nframe\n \n=\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n    \n[\nRoact\n.\nRef\n]\n \n=\n \nfunction\n(\nrbx\n)\n\n        \nprint\n(\n\"Ref was called with\"\n,\n \nrbx\n,\n \n\"of type\"\n,\n \ntypeof\n(\nrbx\n))\n\n    \nend\n\n\n})\n\n\n\nlocal\n \nhandle\n \n=\n \nRoact\n.\nmount\n(\nframe\n)\n\n\n\n-- Output:\n\n\n--     Ref was called with Frame of type Instance\n\n\n\nRoact\n.\nunmount\n(\nhandle\n)\n\n\n\n-- In the output:\n\n\n--     Ref was called with nil of type nil",
            "title": "Refs"
        },
        {
            "location": "/advanced/refs/#refs-in-action",
            "text": "To create a ref, pass a function prop with the key  Roact.Ref  when creating a primitive element.  For example, suppose we wanted to create a search bar that captured cursor focus when any part of it was clicked. We might use a component like this:  --[[      A search bar with an icon and a text box that captures focus for its TextBox      when its icon is clicked   ]]  local   SearchBar   =   Roact . Component : extend ( \"SearchBar\" )  function   SearchBar : init () \n     self . textBoxRef   =   Roact . createRef ()  end  function   SearchBar : render () \n     -- Render our icon and text box side by side in a Frame \n     return   Roact . createElement ( \"Frame\" ,   { \n         Size   =   UDim2 . new ( 0 ,   200 ,   0 ,   20 ), \n     },   { \n         SearchIcon   =   Roact . createElement ( \"ImageButton\" ,   { \n             Size   =   UDim2 . new ( 0 ,   20 ,   0 ,   20 ), \n\n             -- Handle click events on the icon \n             [ Roact . Event . Activated ]   =   function () \n                 self . textBoxRef . current : CaptureFocus () \n             end \n         }), \n\n         SearchTextBox   =   Roact . createElement ( \"TextBox\" ,   { \n             Size   =   UDim2 . new ( 0 ,   180 ,   0 ,   20 ), \n             Position   =   UDim2 . new ( 0 ,   20 ,   0 ,   0 ), \n\n             -- Use Roact.Ref to get a reference to the underlying object \n             [ Roact . Ref ]   =   self . textBoxRef \n         }), \n     })  end  \nWhen a user clicks on the outer  ImageButton , the  captureTextboxFocus  callback will be triggered and the  TextBox  instance will get focus as if it had been clicked on directly.",
            "title": "Refs in Action"
        },
        {
            "location": "/advanced/refs/#refs-during-unmount",
            "text": "Warning  When using the function version of refs, any time a component instance is destroyed or the ref property changes,  nil  will be passed to the old ref function!   local   frame   =   Roact . createElement ( \"Frame\" ,   { \n     [ Roact . Ref ]   =   function ( rbx ) \n         print ( \"Ref was called with\" ,   rbx ,   \"of type\" ,   typeof ( rbx )) \n     end  })  local   handle   =   Roact . mount ( frame )  -- Output:  --     Ref was called with Frame of type Instance  Roact . unmount ( handle )  -- In the output:  --     Ref was called with nil of type nil",
            "title": "Refs During Unmount"
        },
        {
            "location": "/advanced/context/",
            "text": "Warning\n\n\nContext is an unstable feature that's being \nsignificantly\n revised. See \nissue #4\n for current progress.\n\n\n\n\n\n\nInfo\n\n\nThis section is incomplete. It's possible that the context API will change before the existing API is ever documented.",
            "title": "Context"
        },
        {
            "location": "/performance/overview/",
            "text": "Roact operates on the principle that it's much easier to build UI declaratively. When something changes, the UI is rebuilt virtually and then the minimal necessary changes are made to the actual UI elements.\n\n\nFor simple projects, performance is unlikely to be an issue. But Roact is built in Lua, and Lua can be slow. The following pages provide a number of techniques and best practices that you can employ to avoid performance strain with your Roact apps.",
            "title": "Overview"
        },
        {
            "location": "/performance/reduce-reconciliation/",
            "text": "In all likelihood, the primary source of performance gains for your app will come from reducing the amount of work that Roact's reconcilation process requires. This is accomplished by:\n\n\n\n\nIndicating to Roact that some reconciliation work can be skipped\n\n\nMaking sure your elements only change in ways you intended\n\n\n\n\nshouldUpdate\n Lifecycle Method\n\u00b6\n\n\nWhen a Roact Component's state or props change, it will call the Component's \nshouldUpdate\n method to determine whether or not to re-render it. The default implementation will always return true.\n\nfunction\n \nComponent\n:\nshouldUpdate\n(\nnewProps\n,\n \nnewState\n)\n\n    \nreturn\n \ntrue\n\n\nend\n\n\n\n\nIf you have a more complex component that only needs to re-render in certain situations, you can either use \nPureComponent\n (discussed below) or implement your own \nshouldUpdate\n and return \nfalse\n in any case where an update is not required.\n\n\n\n\nWarning\n\n\nManually implementing \nshouldUpdate\n is \ndangerous\n! If done carelessly, it can easily create confusing or subtle bugs.\n\n\nIn most cases, the preferable solution is to use \nPureComponent\n instead, which has a simple and robust implementation of \nshouldUpdate\n.\n\n\n\n\nPureComponent\n\u00b6\n\n\nOne common implementation of \nshouldUpdate\n is to do a shallow comparison between current and previous props and state. \nRoact\n provides an extension of \nRoact.Component\n called \nRoact.PureComponent\n that uses this implementation.\n\n\nLet's use the following example:\n\nlocal\n \nItem\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"Item\"\n)\n\n\n\nfunction\n \nItem\n:\nrender\n()\n\n    \nlocal\n \nicon\n \n=\n \nself\n.\nprops\n.\nicon\n\n    \nlocal\n \nlayoutOrder\n \n=\n \nself\n.\nprops\n.\nlayoutOrder\n\n\n    \n-- Create a list item with the item's icon and name\n\n    \nRoact\n.\ncreateElement\n(\n\"ImageLabel\"\n,\n \n{\n\n        \nLayoutOrder\n \n=\n \nlayoutOrder\n,\n\n        \nImage\n \n=\n \nicon\n,\n\n    \n})\n\n\nend\n\n\n\nlocal\n \nInventory\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"Inventory\"\n)\n\n\n\nfunction\n \nInventory\n:\nrender\n()\n\n    \n-- An Inventory contains a list of items\n\n    \nlocal\n \nitems\n \n=\n \nself\n.\nstate\n.\nitems\n\n\n    \nlocal\n \nitemList\n \n=\n \n{}\n\n    \n-- Create a UIListLayout to space out our items\n\n    \nitemList\n[\n\"Layout\"\n]\n \n=\n \nRoact\n.\ncreateElement\n(\n\"UIListLayout\"\n,\n \n{\n\n        \nSortOrder\n \n=\n \nEnum\n.\nSortOrder\n.\nLayoutOrder\n,\n\n        \nFillDirection\n \n=\n \nEnum\n.\nFillDirection\n.\nVertical\n,\n\n    \n})\n\n    \nfor\n \ni\n,\n \nitem\n \nin\n \nipairs\n(\nitems\n)\n \ndo\n\n        \n-- Add the element to our list\n\n        \nitemList\n[\ni\n]\n \n=\n \nRoact\n.\ncreateElement\n(\nItem\n,\n \n{\n\n            \nlayoutOrder\n \n=\n \ni\n,\n\n            \nicon\n \n=\n \nitem\n.\nicon\n,\n\n        \n})\n\n    \nend\n\n\n    \n-- The Inventory renders a frame containing the list of Items as children\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n        \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n200\n,\n \n0\n,\n \n400\n)\n\n    \n},\n \nitemList\n)\n\n\nend\n\n\n\n\nIn the above example, adding a new item to the \nitems\n prop of the \nInventory\n would cause all of the child \nItem\n elements to re-render, even if they haven't changed at all. This means if you add an item to an \nInventory\n that already has 5 items, the result will be 6 renders of the \nItem\n component.\n\n\nLets change \nItem\n to a \nPureComponent\n:\n\nlocal\n \nItem\n \n=\n \nRoact\n.\nPureComponent\n:\nextend\n(\n\"Item\"\n)\n\n\n\nNow, if we add a new item to the end of the \nInventory\n or change something about an existing item, we'll only re-render the \nInventory\n itself and the modified \nItem\n!\n\n\n\n\nWarning\n\n\nWhen working with \nPureComponent\n, it's critical to use immutable props. Immutability guarantees that a prop's reference will change any time its contents change.\n\n\n\n\n\n\nInfo\n\n\nThere's more to discuss about immutability. It deserves a fully fleshed-out section somewhere!\n\n\n\n\nStable Keys\n\u00b6\n\n\nAnother performance improvement we can make is to use stable, unique keys to refer to our child elements.\n\n\nWhen the list that we pass into the \nInventory\n component changes, Roact reconciles our Roblox UI by adjusting the properties of each primitive according to the new list of elements.\n\n\nFor example, let's suppose our list of items is as follows:\n\n{\n\n    \n{\n \nid\n \n=\n \n\"sword\"\n,\n \nicon\n \n=\n \nswordIcon\n \n},\n \n-- [1]\n\n    \n{\n \nid\n \n=\n \n\"shield\"\n,\n \nicon\n \n=\n \nshieldIcon\n \n},\n \n-- [2]\n\n\n}\n\n\n\n\nIf we add a new item to the beginning, then we'll end up with a list like this:\n\n{\n\n    \n{\n \nid\n \n=\n \n\"potion\"\n,\n \nicon\n \n=\n \npotionIcon\n \n}\n \n-- [1]\n\n    \n{\n \nid\n \n=\n \n\"sword\"\n,\n \nicon\n \n=\n \nswordIcon\n \n},\n \n-- [2]\n\n    \n{\n \nid\n \n=\n \n\"shield\"\n,\n \nicon\n \n=\n \nshieldIcon\n \n},\n \n-- [3]\n\n\n}\n\n\n\n\nWhen Roact reconciles the underlying \nImageLabel\n objects, it will need to change their icons so that the item at \n[1]\n has the potion icon, the item at \n[2]\n has the sword icon, and a new \nImageLabel\n is added at \n[3]\n with the shield icon.\n\n\nWe'd like for Roact to know that the new item was added at \n[1]\n and that the sword and sheild items simply moved down in the list. Then it can adjust their LayoutOrder properties and let the Roblox UI system resolve the rest.\n\n\nSo let's fix it! We'll make our list of \nItem\n elements use the item's id for its keys instead of the indexes in the \nitems\n list:\n\n\nfunction\n \nInventory\n:\nrender\n()\n\n    \n-- An Inventory contains a list of items\n\n    \nlocal\n \nitems\n \n=\n \nself\n.\nstate\n.\nitems\n\n\n    \nlocal\n \nitemList\n \n=\n \n{}\n\n    \nitemList\n[\n\"Layout\"\n]\n \n=\n \nRoact\n.\ncreateElement\n(\n\"UIListLayout\"\n,\n \n{\n\n        \nSortOrder\n \n=\n \nEnum\n.\nSortOrder\n.\nLayoutOrder\n,\n\n        \nFillDirection\n \n=\n \nEnum\n.\nFillDirection\n.\nVertical\n,\n\n    \n})\n\n    \nfor\n \ni\n,\n \nitem\n \nin\n \nipairs\n(\nitems\n)\n \ndo\n\n\n        \n-- Each element is now added at a stable key\n\n\n        \nitemList\n[\nitem\n.\nid\n]\n \n=\n \nRoact\n.\ncreateElement\n(\nItem\n,\n \n{\n\n\n            \nlayoutOrder\n \n=\n \ni\n,\n\n            \nicon\n \n=\n \nitem\n.\nicon\n,\n\n        \n})\n\n    \nend\n\n\n    \n-- The Inventory renders a frame containing the list of Items as children\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n        \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n200\n,\n \n0\n,\n \n400\n)\n\n    \n},\n \nitemList\n)\n\n\nend\n\n\n\n\n\nNow the list of children is keyed by the stable, unique id of the item data. Their positions can change according to their LayoutOrder, but no other properties on the item need to be reconciled. When we add the third element to the list, Roact will set the \nLayoutOrder\n property on for each \nImageLabel\n and only set the \nImage\n property on the newly added one!\n\n\n\n\nInfo\n\n\nSwitching to static keys might seem insignificant for \nthis\n example, but if our \nItem\n component becomes more complicated and our inventory gets bigger, it can make a significant difference!",
            "title": "Reduce Reconcilation"
        },
        {
            "location": "/performance/reduce-reconciliation/#shouldupdate-lifecycle-method",
            "text": "When a Roact Component's state or props change, it will call the Component's  shouldUpdate  method to determine whether or not to re-render it. The default implementation will always return true. function   Component : shouldUpdate ( newProps ,   newState ) \n     return   true  end   If you have a more complex component that only needs to re-render in certain situations, you can either use  PureComponent  (discussed below) or implement your own  shouldUpdate  and return  false  in any case where an update is not required.   Warning  Manually implementing  shouldUpdate  is  dangerous ! If done carelessly, it can easily create confusing or subtle bugs.  In most cases, the preferable solution is to use  PureComponent  instead, which has a simple and robust implementation of  shouldUpdate .",
            "title": "shouldUpdate Lifecycle Method"
        },
        {
            "location": "/performance/reduce-reconciliation/#purecomponent",
            "text": "One common implementation of  shouldUpdate  is to do a shallow comparison between current and previous props and state.  Roact  provides an extension of  Roact.Component  called  Roact.PureComponent  that uses this implementation.  Let's use the following example: local   Item   =   Roact . Component : extend ( \"Item\" )  function   Item : render () \n     local   icon   =   self . props . icon \n     local   layoutOrder   =   self . props . layoutOrder \n\n     -- Create a list item with the item's icon and name \n     Roact . createElement ( \"ImageLabel\" ,   { \n         LayoutOrder   =   layoutOrder , \n         Image   =   icon , \n     })  end  local   Inventory   =   Roact . Component : extend ( \"Inventory\" )  function   Inventory : render () \n     -- An Inventory contains a list of items \n     local   items   =   self . state . items \n\n     local   itemList   =   {} \n     -- Create a UIListLayout to space out our items \n     itemList [ \"Layout\" ]   =   Roact . createElement ( \"UIListLayout\" ,   { \n         SortOrder   =   Enum . SortOrder . LayoutOrder , \n         FillDirection   =   Enum . FillDirection . Vertical , \n     }) \n     for   i ,   item   in   ipairs ( items )   do \n         -- Add the element to our list \n         itemList [ i ]   =   Roact . createElement ( Item ,   { \n             layoutOrder   =   i , \n             icon   =   item . icon , \n         }) \n     end \n\n     -- The Inventory renders a frame containing the list of Items as children \n     return   Roact . createElement ( \"Frame\" ,   { \n         Size   =   UDim2 . new ( 0 ,   200 ,   0 ,   400 ) \n     },   itemList )  end   In the above example, adding a new item to the  items  prop of the  Inventory  would cause all of the child  Item  elements to re-render, even if they haven't changed at all. This means if you add an item to an  Inventory  that already has 5 items, the result will be 6 renders of the  Item  component.  Lets change  Item  to a  PureComponent : local   Item   =   Roact . PureComponent : extend ( \"Item\" )  \nNow, if we add a new item to the end of the  Inventory  or change something about an existing item, we'll only re-render the  Inventory  itself and the modified  Item !   Warning  When working with  PureComponent , it's critical to use immutable props. Immutability guarantees that a prop's reference will change any time its contents change.    Info  There's more to discuss about immutability. It deserves a fully fleshed-out section somewhere!",
            "title": "PureComponent"
        },
        {
            "location": "/performance/reduce-reconciliation/#stable-keys",
            "text": "Another performance improvement we can make is to use stable, unique keys to refer to our child elements.  When the list that we pass into the  Inventory  component changes, Roact reconciles our Roblox UI by adjusting the properties of each primitive according to the new list of elements.  For example, let's suppose our list of items is as follows: { \n     {   id   =   \"sword\" ,   icon   =   swordIcon   },   -- [1] \n     {   id   =   \"shield\" ,   icon   =   shieldIcon   },   -- [2]  }   If we add a new item to the beginning, then we'll end up with a list like this: { \n     {   id   =   \"potion\" ,   icon   =   potionIcon   }   -- [1] \n     {   id   =   \"sword\" ,   icon   =   swordIcon   },   -- [2] \n     {   id   =   \"shield\" ,   icon   =   shieldIcon   },   -- [3]  }   When Roact reconciles the underlying  ImageLabel  objects, it will need to change their icons so that the item at  [1]  has the potion icon, the item at  [2]  has the sword icon, and a new  ImageLabel  is added at  [3]  with the shield icon.  We'd like for Roact to know that the new item was added at  [1]  and that the sword and sheild items simply moved down in the list. Then it can adjust their LayoutOrder properties and let the Roblox UI system resolve the rest.  So let's fix it! We'll make our list of  Item  elements use the item's id for its keys instead of the indexes in the  items  list:  function   Inventory : render () \n     -- An Inventory contains a list of items \n     local   items   =   self . state . items \n\n     local   itemList   =   {} \n     itemList [ \"Layout\" ]   =   Roact . createElement ( \"UIListLayout\" ,   { \n         SortOrder   =   Enum . SortOrder . LayoutOrder , \n         FillDirection   =   Enum . FillDirection . Vertical , \n     }) \n     for   i ,   item   in   ipairs ( items )   do           -- Each element is now added at a stable key           itemList [ item . id ]   =   Roact . createElement ( Item ,   {               layoutOrder   =   i , \n             icon   =   item . icon , \n         }) \n     end \n\n     -- The Inventory renders a frame containing the list of Items as children \n     return   Roact . createElement ( \"Frame\" ,   { \n         Size   =   UDim2 . new ( 0 ,   200 ,   0 ,   400 ) \n     },   itemList )  end   Now the list of children is keyed by the stable, unique id of the item data. Their positions can change according to their LayoutOrder, but no other properties on the item need to be reconciled. When we add the third element to the list, Roact will set the  LayoutOrder  property on for each  ImageLabel  and only set the  Image  property on the newly added one!   Info  Switching to static keys might seem insignificant for  this  example, but if our  Item  component becomes more complicated and our inventory gets bigger, it can make a significant difference!",
            "title": "Stable Keys"
        },
        {
            "location": "/api-reference/",
            "text": "Methods\n\u00b6\n\n\nRoact.createElement\n\u00b6\n\n\nRoact.createElement(component, [props, [children]]) -> RoactElement\n\n\n\n\nCreates a new Roact element representing the given \ncomponent\n.\n\n\nThe \nchildren\n argument is shorthand for adding a \nRoact.Children\n key to \nprops\n. It should be specified as a dictionary of names to elements.\n\n\ncomponent\n can be a string, a function, or a table created by \nComponent:extend\n.\n\n\n\n\nCaution\n\n\nOnce \nprops\n or \nchildren\n are passed into the \ncreateElement\n, make sure not to modify them!\n\n\n\n\nRoact.mount\n\u00b6\n\n\nRoact.mount(element, [parent, [key]]) -> ComponentInstanceHandle\n\n\n\n\n\n\nInfo\n\n\nRoact.mount\n is also available via the deprecated alias \nRoact.reify\n. It will be removed in a future release.\n\n\n\n\nCreates a Roblox Instance given a Roact element, and optionally a \nparent\n to put it in, and a \nkey\n to use as the instance's \nName\n.\n\n\nThe result is a \nComponentInstanceHandle\n, which is an opaque handle that represents this specific instance of the root component. You can pass this to APIs like \nRoact.unmount\n and the future debug API.\n\n\nRoact.reconcile\n\u00b6\n\n\nRoact.reconcile(instanceHandle, element) -> ComponentInstanceHandle\n\n\n\n\nUpdates an existing instance handle with a new element, returning a new handle.\n\n\nreconcile\n can be used to change the props of a component instance created with \nmount\n and is useful for putting Roact content into non-Roact applications.\n\n\n\n\nWarning\n\n\nRoact.reconcile\n takes ownership of the \ninstanceHandle\n passed into it and may unmount it and mount a new tree!\n\n\nMake sure to use the handle that \nreconcile\n returns in any operations after \nreconcile\n, including \nunmount\n.\n\n\n\n\nRoact.unmount\n\u00b6\n\n\nRoact.unmount(instance) -> void\n\n\n\n\n\n\nInfo\n\n\nRoact.unmount\n is also available via the deprecated alias \nRoact.teardown\n. It will be removed in a future release.\n\n\n\n\nDestroys the given \nComponentInstanceHandle\n and all of its descendents. Does not operate on a Roblox Instance -- this must be given a handle that was returned by \nRoact.mount\n.\n\n\nRoact.oneChild\n\u00b6\n\n\nRoact.oneChild(children) -> RoactElement | nil\n\n\nGiven a dictionary of children, returns a single child element.\n\n\nIf \nchildren\n contains more than one child, \noneChild\n function will throw an error. This is intended to denote an error when using the component using \noneChild\n.\n\n\nIf \nchildren\n is \nnil\n or contains no children, \noneChild\n will return \nnil\n.\n\n\nRoact.createRef\n\u00b6\n\n\nRoact.createRef() -> Ref\n\n\n\n\nCreates a new reference object that can be used with \nRoact.Ref\n.\n\n\nConstants\n\u00b6\n\n\nRoact.Children\n\u00b6\n\n\nThis is the key that Roact uses internally to store the children that are attached to a Roact element.\n\n\nIf you're writing a new functional or stateful element that needs to be used like a primitive component, you can access \nRoact.Children\n in your props table.\n\n\nRoact.Ref\n\u00b6\n\n\nUse \nRoact.Ref\n as a key into the props of a primitive element to receive a handle to the underlying Roblox Instance.\n\n\nAssign this key to a reference object created with \ncreateRef\n:\n\nlocal\n \nExampleComponent\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"ExampleComponent\"\n)\n\n\n\nfunction\n \nExampleComponent\n:\ninit\n()\n\n    \n-- Create a reference object.\n\n    \nself\n.\nref\n \n=\n \nRoact\n.\ncreateRef\n()\n\n\nend\n\n\n\nfunction\n \nExampleComponent\n:\nrender\n()\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n        \n-- Use the reference object to point to this rendered instance.\n\n        \n[\nRoact\n.\nRef\n]\n \n=\n \nself\n.\nref\n,\n\n    \n})\n\n\nend\n\n\n\nfunction\n \nExampleComponent\n:\ndidMount\n()\n\n    \n-- Access the current value of a reference object using its current property.\n\n    \nprint\n(\n\"Roblox Instance\"\n,\n \nself\n.\nref\n.\ncurrent\n)\n\n\nend\n\n\n\n\nAlternatively, you can assign it to a function instead:\n\nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n    \n-- The provided function will be called whenever the rendered instance changes.\n\n    \n[\nRoact\n.\nRef\n]\n \n=\n \nfunction\n(\nrbx\n)\n\n        \nprint\n(\n\"Roblox Instance\"\n,\n \nrbx\n)\n\n    \nend\n,\n\n\n})\n\n\n\n\n\n\nWarning\n\n\nWhen \nRoact.Ref\n is given a funciton, Roact does not guarantee when this function will be run relative to the reconciliation of other props. If you try to read a Roblox property that's being set via a Roact prop, you won't know if you're reading it before or after Roact reconciles that prop!\n\n\n\n\n\n\nWarning\n\n\nWhen \nRoact.Ref\n is given a funciton, it will be called with \nnil\n when the component instance is destroyed!\n\n\n\n\nSee \nthe refs guide\n for more details.\n\n\nRoact.Event\n\u00b6\n\n\nIndex into \nRoact.Event\n to receive a key that can be used to connect to events when creating primitive elements:\n\n\nRoact\n.\ncreateElement\n(\n\"ImageButton\"\n,\n \n{\n\n    \n[\nRoact\n.\nEvent\n.\nMouseButton1Click\n]\n \n=\n \nfunction\n(\nrbx\n,\n \nx\n,\n \ny\n)\n\n        \nprint\n(\nrbx\n,\n \n\"clicked at position\"\n,\n \nx\n,\n \ny\n)\n\n    \nend\n,\n\n\n})\n\n\n\n\n\n\n\nInfo\n\n\nEvent callbacks receive the Roblox Instance as the first parameter, followed by any parameters yielded by the event.\n\n\n\n\n\n\nWarning\n\n\nWhen connecting to the \nChanged\n event, be careful not to call \nsetState\n or other functions that will trigger renders. This will cause Roact to re-render during a render, and errors will be thrown!\n\n\n\n\nSee \nthe events guide\n for more details.\n\n\nRoact.Change\n\u00b6\n\n\nIndex into \nRoact.Change\n to receive a key that can be used to connect to \nGetPropertyChangedSignal\n events.\n\n\nIt's similar to \nRoact.Event\n:\n\n\nRoact\n.\ncreateElement\n(\n\"ScrollingFrame\"\n,\n \n{\n\n    \n[\nRoact\n.\nChange\n.\nCanvasPosition\n]\n \n=\n \nfunction\n(\nrbx\n,\n \nposition\n)\n\n        \nprint\n(\n\"ScrollingFrame scrolled to\"\n,\n \nposition\n)\n\n    \nend\n,\n\n\n})\n\n\n\n\n\n\n\nWarning\n\n\nProperty changed events are fired by Roact during the reconciliation phase. Be careful not to accidentally trigger a re-render in the middle of a re-render, or an error will be thrown!\n\n\n\n\nRoact.None\n\u00b6\n\n\nRoact.None\n is a special value that can be used to clear elements from your component state when calling \nsetState\n or returning from \ngetDerivedStateFromProps\n.\n\n\nIn Lua tables, removing a field from state is not possible by setting its value to \nnil\n because \nnil\n values mean the same thing as no value at all. If a field needs to be removed from state, it can be set to \nRoact.None\n when calling \nsetState\n, which will ensure that the resulting state no longer contains it:\n\n\nfunction\n \nMyComponent\n:\ndidMount\n()\n\n    \nself\n:\nsetState\n({\n\n        \nfieldToRemove\n \n=\n \nRoact\n.\nNone\n\n    \n})\n\n\nend\n\n\n\n\n\nComponent Types\n\u00b6\n\n\nRoact.Component\n\u00b6\n\n\nThe base component instance that can be extended to make stateful components.\n\n\nCall \nRoact.Component:extend(\"ComponentName\")\n to make a new stateful component with a given name.\n\n\nRoact.PureComponent\n\u00b6\n\n\nAn extension of \nRoact.Component\n that only re-renders if its props or state change.\n\n\nPureComponent\n implements the \nshouldUpdate\n lifecycle event with a shallow equality comparison. It's optimized for use with immutable data structures, which makes it a perfect fit for use with frameworks like Rodux.\n\n\nPureComponent\n is not \nalways\n faster, but can often result in significant performance improvements when used correctly.\n\n\nRoact.Portal\n\u00b6\n\n\nA component that represents a \nportal\n to a Roblox Instance. Portals are created using \nRoact.createElement\n.\n\n\nAny children of a portal are put inside the Roblox Instance specified by the required \ntarget\n prop. That Roblox Instance should not be one created by Roact.\n\n\nPortals are useful for creating dialogs managed by deeply-nested UI components, and enable Roact to represent and manage multiple disjoint trees at once.\n\n\nSee \nthe Portals guide\n for a small tutorial and more details about portals.\n\n\nComponent API\n\u00b6\n\n\ndefaultProps\n\u00b6\n\n\nstatic defaultProps: Dictionary<any, any>\n\n\n\n\nIf \ndefaultProps\n is defined on a stateful component, any props that aren't specified when a component is created will be taken from there.\n\n\ninit\n\u00b6\n\n\ninit(initialProps) -> void\n\n\n\n\ninit\n is called exactly once when a new instance of a component is created. It can be used to set up the initial \nstate\n, as well as any non-\nrender\n related values directly on the component.\n\n\ninit\n is the only place where you can assign to \nstate\n directly, as opposed to using \nsetState\n:\n\n\nfunction\n \nMyComponent\n:\ninit\n()\n\n    \nself\n.\nstate\n \n=\n \n{\n\n        \nposition\n \n=\n \n0\n,\n\n        \nvelocity\n \n=\n \n10\n\n    \n}\n\n\nend\n\n\n\n\n\nrender\n\u00b6\n\n\nrender() -> Element | nil\n\n\n\n\nrender\n describes what a component should display at the current instant in time.\n\n\n\n\nInfo\n\n\nRoact assumes that \nrender\n act likes a pure function: the result of \nrender\n must depend only on \nprops\n and \nstate\n, and it must not have side-effects.\n\n\n\n\nfunction\n \nMyComponent\n:\nrender\n()\n\n    \n-- This is okay:\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \nself\n.\nprops\n.\ntext\n,\n\n        \nPosition\n \n=\n \nself\n.\nstate\n.\nposition\n\n    \n})\n\n\n    \n-- Ack! Depending on values outside props/state is not allowed!\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \nself\n.\nsomeText\n,\n\n        \nPosition\n \n=\n \ngetMousePosition\n(),\n\n    \n})\n\n\nend\n\n\n\n\n\nrender\n must be defined for all components. The default implementation of \nrender\n throws an error; if your component does not render anything, define a render function that returns \nnil\n explicitly.\n\n\nfunction\n \nMyComponent\n:\nrender\n()\n\n    \nreturn\n \nnil\n\n\nend\n\n\n\n\n\nsetState\n\u00b6\n\n\nsetState(stateUpdater | stateChange) -> void\n\n\n\n\nsetState\n \nrequests\n an update to the component's state. Roact may schedule this update for a later time or resolve it immediately.\n\n\nIf a function is passed to \nsetState\n, that function will be called with the current state and props as arguments:\n\n\nfunction\n \nMyComponent\n:\ndidMount\n()\n\n    \nself\n:\nsetState\n(\nfunction\n(\nprevState\n,\n \nprops\n)\n\n        \nreturn\n \n{\n\n            \ncounter\n \n=\n \nprevState\n.\ncounter\n \n+\n \n1\n\n        \n}\n\n    \nend\n)\n\n\nend\n\n\n\n\n\nIf this function returns \nnil\n, Roact will not schedule a re-render and no state will be updated.\n\n\nIf a table is passed to \nsetState\n, the values in that table will be merged onto the existing state:\n\n\nfunction\n \nMyComponent\n:\ndidMount\n()\n\n    \nself\n:\nsetState\n({\n\n        \nfoo\n \n=\n \n\"bar\"\n\n    \n})\n\n\nend\n\n\n\n\n\nSetting a field in the state to \nRoact.None\n will clear it from the state. This is the only way to remove a field from a component's state!\n\n\n\n\nWarning\n\n\nsetState\n does not always resolve synchronously!\n Roact may batch and reschedule state updates in order to reduce the number of total renders.\n\n\nWhen depending on the previous value of state, like when incrementing a counter, use the functional form to guarantee that all state updates occur!\n\n\nThis behavior will be similar to the future behavior of React 17. See:\n\n\n\n\nRFClarification: why is \nsetState\n asynchronous?\n\n\nDoes React keep the order for state updates?\n\n\n\n\n\n\n\n\nWarning\n\n\nCalling \nsetState\n from any of these places is not allowed at this time and will throw an error:\n\n\n\n\nLifecycle hooks: \nwillUpdate\n, \nwillUnmount\n\n\nInitialization: \ninit\n\n\nPure functions: \nrender\n, \nshouldUpdate\n\n\n\n\n\n\nshouldUpdate\n\u00b6\n\n\nshouldUpdate(nextProps, nextState) -> bool\n\n\n\n\nshouldUpdate\n provides a way to override Roact's rerendering heuristics.\n\n\nRight now, components are re-rendered any time a parent component updates, or when state is updated via \nsetState\n.\n\n\nPureComponent\n implements \nshouldUpdate\n to only trigger a re-render any time the props are different based on shallow equality. In a future Roact update, \nall\n components may implement this check by default.\n\n\ngetElementTraceback\n\u00b6\n\n\ngetElementTraceback() -> string | nil\n\n\n\n\ngetElementTraceback\n gets the stack trace that the component was created in. This allows you to report error messages accurately.\n\n\nLifecycle Methods\n\u00b6\n\n\nIn addition to the base Component API, Roact exposes additional lifecycle methods that stateful components can hook into to be notified of various steps in the rendering process.\n\n\n\n    \n\n        \n\n    \n\n\n\n\n\ndidMount\n\u00b6\n\n\ndidMount() -> void\n\n\n\n\ndidMount\n is fired after the component finishes its initial render. At this point, all associated Roblox Instances have been created, and all components have finished mounting.\n\n\ndidMount\n is a good place to start initial network communications, attach events to services, or modify the Roblox Instance hierarchy.\n\n\nwillUnmount\n\u00b6\n\n\nwillUnmount() -> void\n\n\n\n\nwillUnmount\n is fired right before Roact begins unmounting a component instance's children.\n\n\nwillUnmount\n acts like a component's destructor, and is a good place to disconnect any manually-connected events.\n\n\nwillUpdate\n\u00b6\n\n\nwillUpdate(nextProps, nextState) -> void\n\n\n\n\nwillUpdate\n is fired after an update is started but before a component's state and props are updated.\n\n\ndidUpdate\n\u00b6\n\n\ndidUpdate(previousProps, previousState) -> void\n\n\n\n\ndidUpdate\n is fired after at the end of an update. At this point, the reconciler has updated the properties of any Roblox Instances and the component instance's props and state are up to date.\n\n\ndidUpdate\n is a good place to send network requests or dispatch Rodux actions, but make sure to compare \nself.props\n and \nself.state\n with \npreviousProps\n and \npreviousState\n to avoid triggering too many updates.\n\n\ngetDerivedStateFromProps\n\u00b6\n\n\nstatic getDerivedStateFromProps(nextProps, lastState) -> nextStateSlice\n\n\n\n\nUsed to recalculate any state that depends on being synchronized with \nprops\n.\n\n\nGenerally, you should use \ndidUpdate\n to respond to props changing. If you find yourself copying props values to state as-is, consider using props or memoization instead.\n\n\ngetDerivedStateFromProps\n should return a table that contains the part of the state that should be updated.\n\n\nfunction\n \nMyComponent\n.\ngetDerivedStateFromProps\n(\nnextProps\n,\n \nlastState\n)\n\n    \nreturn\n \n{\n\n        \nsomeValue\n \n=\n \nnextProps\n.\nsomeValue\n\n    \n}\n\n\nend\n\n\n\n\n\nAs with \nsetState\n, you can set use the constant \nRoact.None\n to remove a field from the state.\n\n\n\n\nNote\n\n\ngetDerivedStateFromProps\n is a \nstatic\n lifecycle method. It does not have access to \nself\n, and must be a pure function.",
            "title": "API Reference"
        },
        {
            "location": "/api-reference/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/api-reference/#roactcreateelement",
            "text": "Roact.createElement(component, [props, [children]]) -> RoactElement  Creates a new Roact element representing the given  component .  The  children  argument is shorthand for adding a  Roact.Children  key to  props . It should be specified as a dictionary of names to elements.  component  can be a string, a function, or a table created by  Component:extend .   Caution  Once  props  or  children  are passed into the  createElement , make sure not to modify them!",
            "title": "Roact.createElement"
        },
        {
            "location": "/api-reference/#roactmount",
            "text": "Roact.mount(element, [parent, [key]]) -> ComponentInstanceHandle   Info  Roact.mount  is also available via the deprecated alias  Roact.reify . It will be removed in a future release.   Creates a Roblox Instance given a Roact element, and optionally a  parent  to put it in, and a  key  to use as the instance's  Name .  The result is a  ComponentInstanceHandle , which is an opaque handle that represents this specific instance of the root component. You can pass this to APIs like  Roact.unmount  and the future debug API.",
            "title": "Roact.mount"
        },
        {
            "location": "/api-reference/#roactreconcile",
            "text": "Roact.reconcile(instanceHandle, element) -> ComponentInstanceHandle  Updates an existing instance handle with a new element, returning a new handle.  reconcile  can be used to change the props of a component instance created with  mount  and is useful for putting Roact content into non-Roact applications.   Warning  Roact.reconcile  takes ownership of the  instanceHandle  passed into it and may unmount it and mount a new tree!  Make sure to use the handle that  reconcile  returns in any operations after  reconcile , including  unmount .",
            "title": "Roact.reconcile"
        },
        {
            "location": "/api-reference/#roactunmount",
            "text": "Roact.unmount(instance) -> void   Info  Roact.unmount  is also available via the deprecated alias  Roact.teardown . It will be removed in a future release.   Destroys the given  ComponentInstanceHandle  and all of its descendents. Does not operate on a Roblox Instance -- this must be given a handle that was returned by  Roact.mount .",
            "title": "Roact.unmount"
        },
        {
            "location": "/api-reference/#roactonechild",
            "text": "Roact.oneChild(children) -> RoactElement | nil  Given a dictionary of children, returns a single child element.  If  children  contains more than one child,  oneChild  function will throw an error. This is intended to denote an error when using the component using  oneChild .  If  children  is  nil  or contains no children,  oneChild  will return  nil .",
            "title": "Roact.oneChild"
        },
        {
            "location": "/api-reference/#roactcreateref",
            "text": "Roact.createRef() -> Ref  Creates a new reference object that can be used with  Roact.Ref .",
            "title": "Roact.createRef"
        },
        {
            "location": "/api-reference/#constants",
            "text": "",
            "title": "Constants"
        },
        {
            "location": "/api-reference/#roactchildren",
            "text": "This is the key that Roact uses internally to store the children that are attached to a Roact element.  If you're writing a new functional or stateful element that needs to be used like a primitive component, you can access  Roact.Children  in your props table.",
            "title": "Roact.Children"
        },
        {
            "location": "/api-reference/#roactref",
            "text": "Use  Roact.Ref  as a key into the props of a primitive element to receive a handle to the underlying Roblox Instance.  Assign this key to a reference object created with  createRef : local   ExampleComponent   =   Roact . Component : extend ( \"ExampleComponent\" )  function   ExampleComponent : init () \n     -- Create a reference object. \n     self . ref   =   Roact . createRef ()  end  function   ExampleComponent : render () \n     return   Roact . createElement ( \"Frame\" ,   { \n         -- Use the reference object to point to this rendered instance. \n         [ Roact . Ref ]   =   self . ref , \n     })  end  function   ExampleComponent : didMount () \n     -- Access the current value of a reference object using its current property. \n     print ( \"Roblox Instance\" ,   self . ref . current )  end   Alternatively, you can assign it to a function instead: Roact . createElement ( \"Frame\" ,   { \n     -- The provided function will be called whenever the rendered instance changes. \n     [ Roact . Ref ]   =   function ( rbx ) \n         print ( \"Roblox Instance\" ,   rbx ) \n     end ,  })    Warning  When  Roact.Ref  is given a funciton, Roact does not guarantee when this function will be run relative to the reconciliation of other props. If you try to read a Roblox property that's being set via a Roact prop, you won't know if you're reading it before or after Roact reconciles that prop!    Warning  When  Roact.Ref  is given a funciton, it will be called with  nil  when the component instance is destroyed!   See  the refs guide  for more details.",
            "title": "Roact.Ref"
        },
        {
            "location": "/api-reference/#roactevent",
            "text": "Index into  Roact.Event  to receive a key that can be used to connect to events when creating primitive elements:  Roact . createElement ( \"ImageButton\" ,   { \n     [ Roact . Event . MouseButton1Click ]   =   function ( rbx ,   x ,   y ) \n         print ( rbx ,   \"clicked at position\" ,   x ,   y ) \n     end ,  })    Info  Event callbacks receive the Roblox Instance as the first parameter, followed by any parameters yielded by the event.    Warning  When connecting to the  Changed  event, be careful not to call  setState  or other functions that will trigger renders. This will cause Roact to re-render during a render, and errors will be thrown!   See  the events guide  for more details.",
            "title": "Roact.Event"
        },
        {
            "location": "/api-reference/#roactchange",
            "text": "Index into  Roact.Change  to receive a key that can be used to connect to  GetPropertyChangedSignal  events.  It's similar to  Roact.Event :  Roact . createElement ( \"ScrollingFrame\" ,   { \n     [ Roact . Change . CanvasPosition ]   =   function ( rbx ,   position ) \n         print ( \"ScrollingFrame scrolled to\" ,   position ) \n     end ,  })    Warning  Property changed events are fired by Roact during the reconciliation phase. Be careful not to accidentally trigger a re-render in the middle of a re-render, or an error will be thrown!",
            "title": "Roact.Change"
        },
        {
            "location": "/api-reference/#roactnone",
            "text": "Roact.None  is a special value that can be used to clear elements from your component state when calling  setState  or returning from  getDerivedStateFromProps .  In Lua tables, removing a field from state is not possible by setting its value to  nil  because  nil  values mean the same thing as no value at all. If a field needs to be removed from state, it can be set to  Roact.None  when calling  setState , which will ensure that the resulting state no longer contains it:  function   MyComponent : didMount () \n     self : setState ({ \n         fieldToRemove   =   Roact . None \n     })  end",
            "title": "Roact.None"
        },
        {
            "location": "/api-reference/#component-types",
            "text": "",
            "title": "Component Types"
        },
        {
            "location": "/api-reference/#roactcomponent",
            "text": "The base component instance that can be extended to make stateful components.  Call  Roact.Component:extend(\"ComponentName\")  to make a new stateful component with a given name.",
            "title": "Roact.Component"
        },
        {
            "location": "/api-reference/#roactpurecomponent",
            "text": "An extension of  Roact.Component  that only re-renders if its props or state change.  PureComponent  implements the  shouldUpdate  lifecycle event with a shallow equality comparison. It's optimized for use with immutable data structures, which makes it a perfect fit for use with frameworks like Rodux.  PureComponent  is not  always  faster, but can often result in significant performance improvements when used correctly.",
            "title": "Roact.PureComponent"
        },
        {
            "location": "/api-reference/#roactportal",
            "text": "A component that represents a  portal  to a Roblox Instance. Portals are created using  Roact.createElement .  Any children of a portal are put inside the Roblox Instance specified by the required  target  prop. That Roblox Instance should not be one created by Roact.  Portals are useful for creating dialogs managed by deeply-nested UI components, and enable Roact to represent and manage multiple disjoint trees at once.  See  the Portals guide  for a small tutorial and more details about portals.",
            "title": "Roact.Portal"
        },
        {
            "location": "/api-reference/#component-api",
            "text": "",
            "title": "Component API"
        },
        {
            "location": "/api-reference/#defaultprops",
            "text": "static defaultProps: Dictionary<any, any>  If  defaultProps  is defined on a stateful component, any props that aren't specified when a component is created will be taken from there.",
            "title": "defaultProps"
        },
        {
            "location": "/api-reference/#init",
            "text": "init(initialProps) -> void  init  is called exactly once when a new instance of a component is created. It can be used to set up the initial  state , as well as any non- render  related values directly on the component.  init  is the only place where you can assign to  state  directly, as opposed to using  setState :  function   MyComponent : init () \n     self . state   =   { \n         position   =   0 , \n         velocity   =   10 \n     }  end",
            "title": "init"
        },
        {
            "location": "/api-reference/#render",
            "text": "render() -> Element | nil  render  describes what a component should display at the current instant in time.   Info  Roact assumes that  render  act likes a pure function: the result of  render  must depend only on  props  and  state , and it must not have side-effects.   function   MyComponent : render () \n     -- This is okay: \n     return   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   self . props . text , \n         Position   =   self . state . position \n     }) \n\n     -- Ack! Depending on values outside props/state is not allowed! \n     return   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   self . someText , \n         Position   =   getMousePosition (), \n     })  end   render  must be defined for all components. The default implementation of  render  throws an error; if your component does not render anything, define a render function that returns  nil  explicitly.  function   MyComponent : render () \n     return   nil  end",
            "title": "render"
        },
        {
            "location": "/api-reference/#setstate",
            "text": "setState(stateUpdater | stateChange) -> void  setState   requests  an update to the component's state. Roact may schedule this update for a later time or resolve it immediately.  If a function is passed to  setState , that function will be called with the current state and props as arguments:  function   MyComponent : didMount () \n     self : setState ( function ( prevState ,   props ) \n         return   { \n             counter   =   prevState . counter   +   1 \n         } \n     end )  end   If this function returns  nil , Roact will not schedule a re-render and no state will be updated.  If a table is passed to  setState , the values in that table will be merged onto the existing state:  function   MyComponent : didMount () \n     self : setState ({ \n         foo   =   \"bar\" \n     })  end   Setting a field in the state to  Roact.None  will clear it from the state. This is the only way to remove a field from a component's state!   Warning  setState  does not always resolve synchronously!  Roact may batch and reschedule state updates in order to reduce the number of total renders.  When depending on the previous value of state, like when incrementing a counter, use the functional form to guarantee that all state updates occur!  This behavior will be similar to the future behavior of React 17. See:   RFClarification: why is  setState  asynchronous?  Does React keep the order for state updates?     Warning  Calling  setState  from any of these places is not allowed at this time and will throw an error:   Lifecycle hooks:  willUpdate ,  willUnmount  Initialization:  init  Pure functions:  render ,  shouldUpdate",
            "title": "setState"
        },
        {
            "location": "/api-reference/#shouldupdate",
            "text": "shouldUpdate(nextProps, nextState) -> bool  shouldUpdate  provides a way to override Roact's rerendering heuristics.  Right now, components are re-rendered any time a parent component updates, or when state is updated via  setState .  PureComponent  implements  shouldUpdate  to only trigger a re-render any time the props are different based on shallow equality. In a future Roact update,  all  components may implement this check by default.",
            "title": "shouldUpdate"
        },
        {
            "location": "/api-reference/#getelementtraceback",
            "text": "getElementTraceback() -> string | nil  getElementTraceback  gets the stack trace that the component was created in. This allows you to report error messages accurately.",
            "title": "getElementTraceback"
        },
        {
            "location": "/api-reference/#lifecycle-methods",
            "text": "In addition to the base Component API, Roact exposes additional lifecycle methods that stateful components can hook into to be notified of various steps in the rendering process.",
            "title": "Lifecycle Methods"
        },
        {
            "location": "/api-reference/#didmount",
            "text": "didMount() -> void  didMount  is fired after the component finishes its initial render. At this point, all associated Roblox Instances have been created, and all components have finished mounting.  didMount  is a good place to start initial network communications, attach events to services, or modify the Roblox Instance hierarchy.",
            "title": "didMount"
        },
        {
            "location": "/api-reference/#willunmount",
            "text": "willUnmount() -> void  willUnmount  is fired right before Roact begins unmounting a component instance's children.  willUnmount  acts like a component's destructor, and is a good place to disconnect any manually-connected events.",
            "title": "willUnmount"
        },
        {
            "location": "/api-reference/#willupdate",
            "text": "willUpdate(nextProps, nextState) -> void  willUpdate  is fired after an update is started but before a component's state and props are updated.",
            "title": "willUpdate"
        },
        {
            "location": "/api-reference/#didupdate",
            "text": "didUpdate(previousProps, previousState) -> void  didUpdate  is fired after at the end of an update. At this point, the reconciler has updated the properties of any Roblox Instances and the component instance's props and state are up to date.  didUpdate  is a good place to send network requests or dispatch Rodux actions, but make sure to compare  self.props  and  self.state  with  previousProps  and  previousState  to avoid triggering too many updates.",
            "title": "didUpdate"
        },
        {
            "location": "/api-reference/#getderivedstatefromprops",
            "text": "static getDerivedStateFromProps(nextProps, lastState) -> nextStateSlice  Used to recalculate any state that depends on being synchronized with  props .  Generally, you should use  didUpdate  to respond to props changing. If you find yourself copying props values to state as-is, consider using props or memoization instead.  getDerivedStateFromProps  should return a table that contains the part of the state that should be updated.  function   MyComponent . getDerivedStateFromProps ( nextProps ,   lastState ) \n     return   { \n         someValue   =   nextProps . someValue \n     }  end   As with  setState , you can set use the constant  Roact.None  to remove a field from the state.   Note  getDerivedStateFromProps  is a  static  lifecycle method. It does not have access to  self , and must be a pure function.",
            "title": "getDerivedStateFromProps"
        }
    ]
}